#' Import and normalize raw current data
#'
#' `make_normalized_EPSC_data()` creates a dataframe of evoked or spontaneous
#' current data from a raw .csv file. The function will create a new column
#' containing the evoked or spontaneous current amplitudes normalized relative
#' to the mean current amplitude during the baseline period. For evoked current
#' data, the function also adds a column for the paired pulse ratio (`PPR = P2/P1`, where `P2` is the amplitude of the
#' second evoked current).
#'
#' @param filename A filepath to a .csv file. See [add_new_cells()] for the
#'   function that will merge raw data (a .csv with 4 columns: `letter`, `ID`,
#'   `P1`, and `P2`) and a `cell-characteristics.csv` file (with columns for
#'   factors like `animal`, `age`, `sex`, `synapses`). Please see the section on
#'   "Required columns" below.
#' @param current_type A character describing the current type. Allowed values
#'   are `"eEPSC"` or `"sEPSC"`.
#' @param min_time_value Minimum time value (numeric; in minutes), which
#'   defaults to `0`.
#' @param max_time_value Maximum recording length (numeric; in minutes). All
#'   data points will be filtered to time values less than or equal to this
#'   value. Defaults to `25`.
#' @param baseline_length Length of the baseline (numeric; in minutes). Refers
#'   to data collected before applying a hormone, antagonist, or a protocol like
#'   high frequency stimulation. Defaults to `5`.
#' @param interval_length Length of each interval (numeric; in minutes). Used to
#'   divide the dataset into broad ranges for statistical analysis. Important!
#'   `max_recording_length` must be evenly divisible by `interval_length`.
#'   Defaults to `5`.
#' @param decimal_places A numeric value indicating the number of decimal places
#'   the data should be rounded to. Used to reduce file size and prevent an
#'   incorrect representation of the number of significant digits.
#' @param negative_transform_currents A character (`"yes"` or `"no"`) describing if
#'   `P1` and `P2` should be negative transformed. If "yes", the values will be
#'   multiplied by (-1). This only applies when `current_type == "eEPSC"` - It
#'   will be ignored for spontaneous current data.
#' @param save_output_as_RDS A character (`"yes"` or `"no"`) describing if the
#'   resulting object should be saved as an RDS file in the raw data folder.
#'
#' @returns A dataframe that can be viewed and used for further analyses in R.
#'   New or modified columns include:
#' \itemize{
#'  \item `P1` (for evoked currents only) May be negative-transformed if
#'  `negative_transform` == `"yes"`
#'  \item `P2` (for evoked currents only) May be negative-transformed if
#'  `negative_transform` == `"yes"`
#'  \item `PPR` (for evoked currents only) A numeric value that represents the
#'  paired pulse ratio (PPR) of the evoked currents, generated using
#'  `dplyr::mutate(PPR = P2/P1)`.
#'  \item `interval` A character value indicating the interval that the data
#'  point belongs to. For example, `interval` will be `"t0to5"` for any data
#'  points from 0 to 5 minutes. Example values: `"t0to5"`, `"t5to10"`, etc.
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to `TRUE` when time is within the baseline period
#'  (e.g. `Time <= 5`) and `FALSE` at all other times.
#'  \item `baseline_mean` A numeric value representing the mean evoked current
#'  amplitude during the baseline period. There is a different baseline_mean for
#'  each letter.
#'  \item `P1_transformed` (for evoked currents only) A numeric value
#'  representing the first evoked current
#'  amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline.
#'  \item `P2_transformed` (for evoked currents only) A numeric value
#'  representing the second evoked current amplitude (pA) normalized relative to
#'  the mean amplitude during the recording's baseline.
#'  \item `amplitude_transformed` (for spontaneous currents only) A numeric
#'  value representing the spontaneous current amplitude (pA) normalized
#'  relative to the mean amplitude during the recording's baseline.
#' }
#'
#' @section Required basic columns:
#' It doesn't matter if the data are evoked or current type - these columns
#' should be included in your data.
#' \itemize{
#'  \item `letter` A character value that is a unique identifier for a single
#'  recording. Used to link data sets for evoked or spontaneous currents and
#'  cell-characteristics.
#'  \item `synapses` A character value (e.g. `"Glutamate"` or `"GABA"`).
#'  \item `sex` A character value (e.g. `"Male"` or `"Female"`).
#'  \item `treatment` A character value (e.g. `"Control"`, `"HNMPA"`).
#'  \item `time` A numeric value that represents time in minutes. This column is
#'  autogenerated in [add_new_cells()].
#'  \item `ID` A character value for the recording filename.
#'  \item `X` A numeric value representing the x-value of the cell's location in
#'  µm. Leave this blank if you don't have this data.
#'  \item `Y` A numeric value representing the y-value of the cell's location in
#'  µm. Leave this blank if you don't have this data.
#'  \item `age` A numeric value representing the animal's age. Can be any value
#'  as long as the time units are consistent throughout (e.g. don't mix up days
#'  and months when reporting animal ages).
#'  \item `animal` A numeric value representing the animal's ID or number.
#'  \item `category` A numeric value representing the experiment type. Used to
#'  assign top-level groups for further analyses, with `treatment` as subgroups.
#'  \item `cell` A character or numeric value representing the cell. For
#'  example, use `3.1.1` for animal #3, slice #1, cell #1.
#'  \item `R_a` A list of values for the access resistance, which would have been monitored at several timepoints throughout the recording. See the documentation for the `R_a` column in the documentation for `sample_cell_characteristics` with `?sample_cell_characteristics`.
#'  \item `notes` An optional character column with notes about any issues, sweeps that were removed during Clampfit processing, etc.
#'  \item `days_alone` A numeric value describing the number of days that the animal was left alone in a cage. This typically ranges from 0 to 2. Fasted animals will have 1 day alone.
#'  \item `animal_or_slicing_problems` A character value (`"yes"` or `"no"`) describing if there were any issues with the animal (for example, the animal was unusually anxious) or slicing (there were delays during the process, the slices were crumpling, etc.).
#' }
#'
#' **Evoked current data**:
#'
#' If the data are evoked currents (`current_type == "eEPSC"`), the data must
#' contain the basic columns mentioned in **Required basic columns** plus these
#' columns:
#'
#' \itemize{
#'  \item `P1` A numeric value representing the
#'  amplitude of the first evoked current in pA.
#'  \item `P2` A numeric value representing the
#'  amplitude of the second evoked current in pA.
#' }
#'
#' **Spontaneous current data:**
#'
#' If the data are spontaneous currents (`current_type == "sEPSC"`), the data
#' must contain the basic columns mentioned in **Required basic columns** plus
#' these columns:
#' \itemize{
#'  \item `recording_num` A numeric value representing the recording number.
#'  This was incorporated before we switched to concatenating all recordings
#'  into one, but it needs to remain here to prevent breaking previous projects.
#'  It should be set to `1`.
#'  \item `trace` A numeric value representing the trace (automatically
#'  generated in Clampfit) where the current occurred.
#'  \item `time_of_peak` A numeric value representing the time of the peak in
#'  milliseconds relative to trace number. This is automatically calculated in
#'  Clampfit.
#'  \item `time` A numeric value representing the absolute time when the current
#'  happened, relative to the start of the recording. This is autogenerated. See
#'  [add_new_cells()] for a description of how the true time value (`time`) is
#'  calculated from the `recording_num` and `trace.`
#'  \item `amplitude` A numeric value representing the amplitude of the evoked
#'  current in pA.
#' }
#'
#' @examples
#' make_normalized_EPSC_data(
#'   filename = import_ext_data("sample_eEPSC_data.csv"),
#'   current_type = "eEPSC",
#'   min_time_value = 0,
#'   max_time_value = 25,
#'   interval_length = 5,
#'   baseline_length = 5,
#'   decimal_places = 2,
#'   negative_transform_currents = "yes"
#' )
#'
#' @seealso [add_new_cells()] to add new recording data to your existing raw
#'   csv. It will merge raw data (a .csv with 4 columns: `letter`, `ID`, `P1`,
#'   and `P2`) and a `cell-characteristics.csv` file (with columns for factors
#'   like `animal`, `age`, `sex`, `synapses`).
#' @seealso [add_new_cells()] and [make_summary_EPSC_data()] for
#'   functions that further process the data.
#'
#' @export

make_normalized_EPSC_data <- function(filename = "Data/Sample-eEPSC-data.csv",
                                      current_type = "eEPSC",
                                      min_time_value = 0,
                                      max_time_value = 25,
                                      baseline_length = 5,
                                      interval_length = 5,
                                      decimal_places = 2,
                                      negative_transform_currents = "yes",
                                      save_output_as_RDS = "no") {
  list_of_argument_names <- c(filename, current_type)

  if (is.null(current_type) ||
    length(current_type) != 1L ||
    !current_type %in% c("eEPSC", "sEPSC")) {
    cli::cli_abort(c("x" = "'current_type' argument must be either 'eEPSC' or 'sEPSC'"))
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`save_output_as_RDS` argument must be one of: \"yes\" or \"no\""))
  }

  if (!negative_transform_currents %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`negative_transform_currents` argument must be either 'yes' or 'no'"))
  }


  if (current_type == "eEPSC") {
    if (any(grepl("sEPSC", list_of_argument_names))) {
      cli::cli_abort(c(
        "x" = paste0(
          "current_type = \"",
          current_type,
          "\" but some arguments have the text ",
          "\"sEPSC\"."
        ),
        "i" = "Are you sure that you selected the correct current type?"
      ))
    }
  }

  if (current_type == "sEPSC") {
    if (any(grepl("eEPSC", list_of_argument_names))) {
      cli::cli_abort(c(
        "x" = paste0(
          "current_type = \"",
          current_type,
          "\" but some arguments have the text ",
          "\"eEPSC\"."
        ),
        "i" = "Are you sure that you selected the correct current type?"
      ))
    }
  }

  if (max_time_value %% baseline_length != 0) {
    cli::cli_abort(c("x" = paste0(
      "max_time_value is ",
      max_time_value,
      ", which is not divisible by interval_length ",
      interval_length
    )))
  }

  if (!is.numeric(decimal_places)) {
    cli::cli_abort(c("x" = "`decimal_places` must be a numeric value"))
  }


  raw_df <- utils::read.csv(here::here(filename), header = TRUE) %>%
    dplyr::rename_with(tolower)

  raw_df <- raw_df %>%
    dplyr::mutate(
      days_alone = factor(.data$days_alone),
      animal_or_slicing_problems = factor(.data$animal_or_slicing_problems)
    )

  if (current_type == "eEPSC") {
    raw_df <- raw_df %>%
      dplyr::rename(
        ID = .data$id,
        P1 = .data$p1,
        P2 = .data$p2,
        X = .data$x,
        Y = .data$y,
        R_a = .data$r_a
      )
  }

  if (current_type == "sEPSC") {
    raw_df <- raw_df %>%
      dplyr::rename(
        ID = .data$id,
        X = .data$x,
        Y = .data$y,
        R_a = .data$r_a
      )
  }

  raw_df <- raw_df %>%
    dplyr::mutate(dplyr::across(
      c(
        .data$ID,
        .data$letter,
        .data$category,
        .data$treatment,
        .data$sex,
        .data$synapses
      ), \(x) as.factor(x)
    )) %>%
    dplyr::filter(.data$time <= max_time_value)


  if (current_type == "eEPSC") {
    if (negative_transform_currents == "yes") {
      raw_df <- raw_df %>%
        dplyr::mutate(
          P1 = .data$P1 * -1,
          # Need positive current amplitude values to make plots more intuitive
          P2 = .data$P2 * -1,
          PPR = .data$P2 / .data$P1
        )
    } else {
      raw_df <- raw_df %>%
        dplyr::mutate(PPR = .data$P2 / .data$P1)
    }
  }

  # Divide data into intervals (e.g. 5-min intervals)


  time_sequence <- seq(from = min_time_value, to = max_time_value, by = interval_length)
  time_labels <- utils::head(
    paste0("t", time_sequence, "to", time_sequence + interval_length),
    -1
  )

  raw_df <- raw_df %>%
    dplyr::mutate(
      interval = cut(
        .data$time,
        breaks = time_sequence,
        include.lowest = TRUE,
        labels = time_labels
      )
    ) %>%
    dplyr::group_by(.data$letter)

  # Within each cell, normalize all of the eEPSC amplitudes
  # relative to the mean baseline amplitude

  if (current_type == "eEPSC") {
    raw_df <- raw_df %>%
      dplyr::mutate(
        baseline_range = (.data$time <= baseline_length),
        baseline_mean = sum(.data$P1 * .data$baseline_range) / sum(.data$baseline_range),
        P1_transformed = (.data$P1 / .data$baseline_mean) * 100,
        P2_transformed = (.data$P2 / .data$baseline_mean) * 100
      ) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))
  }

  if (current_type == "sEPSC") {
    raw_df <- raw_df %>%
      dplyr::mutate(
        baseline_range = (.data$time <= baseline_length),
        baseline_mean = sum(.data$amplitude * .data$baseline_range) / sum(.data$baseline_range),
        amplitude_transformed = (.data$amplitude / .data$baseline_mean) * 100
      ) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))
  }

  if (save_output_as_RDS == "yes") {
    RDS_path <- "Data/Output-Data-from-R/"

    if (!dir.exists(here::here(RDS_path))) {
      dir.create(here::here(RDS_path), recursive = TRUE)

      cli::cli_alert_success(cli::col_green(paste0("Created new folder called ", RDS_path)))
    }

    saveRDS(raw_df, file = here::here(
      paste0(
        RDS_path,
        "raw_", current_type, "_df.rds"
      )
    ))
  }

  return(raw_df)
}


#' Prune and summarize raw current data per minute
#'
#' `make_pruned_eEPSC_df()` creates a dataframe of evoked or spontaneous current
#' data summarized per minute (or some other user-defined interval). Current
#' amplitudes are collapsed down into the mean amplitude per minute. This is
#' equivalent to GraphPad Prism's "prune rows" function to reduce data to
#' summary values for every n rows.
#'
#' @param data A `data.frame` object generated using
#'   [make_normalized_EPSC_data()]. It must contain the columns outlined in the
#'   Required columns section below, which will already be generated for you
#'   from the output of [make_normalized_EPSC_data()].
#' @inheritParams make_normalized_EPSC_data
#' @inheritParams add_new_cells
#' @param interval_length Length of each interval (in minutes). Used to divide
#'   the dataset into broad ranges for statistical analysis. Defaults to `1` for
#'   one summary point per minute.
#'
#' @returns A list containing 3 dataframes that can be viewed and used for
#'   further analyses in R. These dataframes are:
#'
#'   \itemize{
#'    \item `individual_cells`
#'    \item `for_table`
#'    \item `all_cells`
#'   }
#'
#'   I highly recommend assigning the list to an object
#'   named something like `pruned_eEPSC_df` to make it easy to reference the
#'   dataframes with logical names (e.g. `pruned_eEPSC_df$all_cells`). The
#'   dataframes are:
#'
#' \itemize{
#'  \item `individual_cells` A dataframe containing current data for each
#'  individual cell, but the data are reduced to a summary  point per per minute
#'  (or another value if a different `interval_length` is set). This dataframe
#'  contains columns already in the raw data, like `category`, `letter` and
#'  `sex` plus  new columns.
#'
#'  New columns for evoked current data (`current_type == "eEPSC"`) include:
#'  \itemize{
#'    \item `interval_pruned` A character value describing the interval that was
#'    used for the pruning function. If the data are pruned per minute, this
#'    will be "t0to1", "t1to2", "t2to3", etc.
#'    \item `mean_P1` The mean amplitude (in pA) of the first evoked current
#'    (P1) during a specific interval. This is an average of all data points
#'    within each interval. For example, the `mean_P1` for the interval "t0to1"
#'    contains the average current amplitude of all data points within the first
#'    minute of the recording.
#'    \item `sd_P1` The standard deviation of P1.
#'    \item `n` The number of data points used.
#'    \item `se` The standard error of P1.
#'    \item `cv` The coefficient of variation of P1.
#'    \item `cv_inverse_square` The inverse coefficient of variation, which is
#'    then squared. This is to enable variance analysis, as in
#'    [Huijstee & Kessels (2020)](https://doi.org/10.1016/j.jneumeth.2019.108526).
#'    \item `baseline_mean` The mean amplitude of the first evoked current
#'    during the baseline period.
#'    \item `category, letter, sex, treatment, etc.` Columns which are
#'    from the raw data. For a definition of these columns, please see the
#'    documentation for [make_normalized_EPSC_data()].
#'    \item `time` The upper time value of the interval (e.g. 2 minutes for
#'    "t1to2") which is used on the x-axis of plots such as in
#'    [plot_raw_current_data()].
#'  }
#'
#'  New columns for spontaneous current data (`current_type == "sEPSC"`)
#'  include:
#'  \itemize{
#'    \item `mean_amplitude` The mean amplitude of the normalized spontaneous
#'    current amplitude for a specific interval (obtained from
#'    [make_normalized_EPSC_data()]).
#'    \item `mean_raw_amplitude` The mean amplitude of the raw spontaneous
#'    current amplitude for a specific interval.
#'    \item `sd_amplitude` The standard deviation of the normalized spontaneous
#'    current amplitudes.
#'    \item `n` The number of currents
#'    \item `frequency` The frequency (in Hz) of currents during the interval.
#'    \item `se` The standard error of the normalized spontaneous current
#'    amplitudes.
#'    \item `letter, category, interval, synapses` Columns inherited from the
#'    raw data.
#'    \item `time` The upper time value of the interval (e.g. 2 minutes for
#'    "t1to2") which is used on the x-axis of plots such as in
#'    [plot_summary_current_data()].
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to TRUE when time is within the baseline period
#'  (e.g. Time <= 5) and FALSE at all other times.
#'    \item `baseline_mean_frequency` The mean spontaneous frequency during the
#'    baseline period.
#'    \item `frequency_transformed` The spontaneous current frequency (in Hz),
#'    normalized relative to the baseline current frequency.
#'  }
#'
#'  \item `for_table` A dataframe containing two columns: letter and
#'  `P1_transformed` (for `eEPSC`) or `spont_amplitude_transformed` (for
#'  `sEPSC`). The current data is collapsed into a single row for each letter,
#'  with the current data for each letter stored as a list. This is required to
#'  create sparklines of current amplitude over time within the cell summary
#'  table. See make_cell_summary_df() and make_interactive_summary_table().
#'
#'  \item `all_cells` A dataframe consisting of all data within a single
#'  treatment grouped and summarized per minute (or some other variable if you
#'  change `interval_length` to be something other than `1`). Columns like
#'  `category` and `sex` are retained from the raw data.
#'
#'  New columns for evoked current data (`current_type == "eEPSC"`) are:
#'  \itemize{
#'    \item `interval_pruned` A character value describing the interval that was
#'    used for the pruning function. If the data are pruned per minute, this
#'    will be "t0to1", "t1to2", "t2to3", etc.
#'    \item `mean_P1_all_cells` The mean amplitude (in pA) of the first evoked
#'    current (P1) during a specific interval across all cells.
#'    \item `sd_P1_all_cells` The standard deviation of P1.
#'    \item `n` The number of data points used.
#'    \item `se_P1_all_cells` The standard error of P1.
#'    \item `cv_P1_all_cells` The coefficient of variation of P1.
#'  }
#'
#'  New columns for spontaneous current data (`current_type == "sEPSC"`) are:
#'  \itemize{
#'    \item `interval_pruned` A character value describing the interval that was
#'    used for the pruning function. If the data are pruned per minute, this
#'    will be "t0to1", "t1to2", "t2to3", etc.
#'    \item `mean_all_amplitude` The mean normalized amplitude (in % Baseline)
#'    of the spontaneous current amplitudes during a specific interval across
#'    all cells.
#'    \item `mean_all_raw_amplitude` The mean raw amplitude (in pA) of the
#'    spontaneous current amplitudes during a specific interval across all
#'    cells.
#'    \item `sd_all_amplitude` The standard deviation of the normalized
#'    spontaneous current amplitudes across all cells.
#'    \item `n` The number of data points used.
#'    \item `se_all_amplitude` The standard error of the normalized spontaneous
#'    currents across all cells.
#'    \item `sd_all_raw_amplitude` The standard deviation of the raw
#'    spontaneous current amplitudes across all cells.
#'    \item `se_raw_amplitude` The standard error of the raw spontaneous
#'    currents across all cells.
#'    \item `mean_all_frequency` The mean normalized frequency (% Baseline
#'    frequency) of all spontaneous current amplitudes across all cells during
#'    the interval.
#'    \item `sd_all_frequency` The standard deviation of the normalized
#'    frequency of all spontaneous current amplitudes across all cells during
#'    the interval.
#'    \item `se_frequency` The standard error of the normalized
#'    frequency of all spontaneous current amplitudes across all cells during
#'    the interval.
#'    \item `mean_all_raw_frequency` The mean raw frequency (Hz) of all
#'    spontaneous current amplitudes across all cells during the interval.
#'    \item `sd_all_raw_frequency` The standard deviation of the raw
#'    frequency of all spontaneous current amplitudes across all cells during
#'    the interval.
#'    \item `se_raw_frequency` The standard error of the raw
#'    frequency of all spontaneous current amplitudes across all cells during
#'    the interval.
#'  }
#' }
#'
#' @inheritSection make_normalized_EPSC_data Required basic columns
#'
#' @section Required evoked currents columns:
#'
#' These columns will all be generated automatically in
#' [make_normalized_EPSC_data()], but for more details, you can look at
#' [sample_raw_eEPSC_df] to see an example of what the incoming raw dataset in
#' the `data` argument should look like. If the data are evoked currents
#' (`current_type == "eEPSC"`), the data must contain the basic columns
#' mentioned in **Required basic columns** plus these columns:
#'
#' \itemize{
#'  \item `PPR` A numeric value that represents the paired pulse ratio (PPR) of
#'  the evoked currents, generated in
#'  [make_normalized_EPSC_data()].
#'  \item `interval` A character value indicating the interval that the data
#'  belong to (e.g. "t0to5" for the first 5 minutes, "t5to10"). Generated
#'  automatically in [make_normalized_EPSC_data()].
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to TRUE when time is within the baseline period
#'  (e.g. `time <= 5`) and FALSE at all other times. Generated automatically in
#'  [make_normalized_EPSC_data()].
#'  \item `baseline_mean` A numeric value representing the mean evoked current
#'  amplitude during the baseline period. There is a different baseline_mean for
#'  each letter. Generated automatically in [make_normalized_EPSC_data()].
#'  \item `P1_transformed` A numeric value representing the first evoked current
#'  amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline. Generated automatically in
#'  [make_normalized_EPSC_data()].
#'  \item `P2_transformed` A numeric value representing the second evoked
#'  current amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline. Generated automatically in
#'  [make_normalized_EPSC_data()].
#' }
#' @section Required spontaneous currents columns:
#'
#' If the data are spontaneous currents (current_type == "sEPSC"), the data must
#' contain the basic columns mentioned in **Required basic columns** plus the
#' columns listed below. For more detail, have a look at [sample_raw_sEPSC_df]
#' to see an example of what the incoming raw dataset in the `data` argument
#' should look like.
#'
#' NOTE: If you exported your spontaneous data from the histogram tool in
#' ' MiniAnalysis, you must set `software` to "MiniAnalysis".
#'
#' \itemize{
#'  \item `interval` A character value indicating the interval that the data
#'  belong to (e.g. "t0to5" for the first 5 minutes, "t5to10"). Generated
#'  automatically in [make_normalized_EPSC_data()].
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to `TRUE` when time is within the baseline period
#'  (e.g. `Time <= 5`) and `FALSE` at all other times. Generated
#'  automatically in [make_normalized_EPSC_data()].
#'  \item `baseline_mean` A numeric value representing the mean evoked current
#'  amplitude during the baseline period. There is a different baseline_mean for
#'  each letter. Generated automatically in [make_normalized_EPSC_data()].
#'  \item `amplitude_transformed` A numeric value representing the spontaneous
#'  current amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline. Generated automatically in
#'  [make_normalized_EPSC_data()].
#' }
#'
#' @export
#'
#' @seealso [make_variance_data()] to see an example of how you can use pruned
#'   data to perform variance analysis to determine the mechanism of changing
#'   synaptic plasticity.
#'
#' @seealso [make_normalized_EPSC_data()] for a description of how baseline
#'   normalization works.
#'
#' @examples
#'
#' # Evoked Current Data
#' make_pruned_EPSC_data(
#'   data = sample_raw_eEPSC_df,
#'   current_type = "eEPSC",
#'   min_time_value = 0,
#'   max_time_value = 25,
#'   baseline_length = 5,
#'   interval_length = 1,
#'   decimal_places = 2
#' )
#'
#' # Spontaneous Current Data
#' make_pruned_EPSC_data(
#'   data = sample_raw_sEPSC_df,
#'   current_type = "sEPSC",
#'   min_time_value = 0,
#'   max_time_value = 25,
#'   baseline_length = 5,
#'   interval_length = 1,
#'   decimal_places = 2
#' )
make_pruned_EPSC_data <- function(data = patchclampplotteR::sample_raw_eEPSC_df,
                                  current_type = "eEPSC",
                                  min_time_value = 0,
                                  max_time_value = 25,
                                  baseline_length = 5,
                                  interval_length = 1,
                                  software = "Clampfit",
                                  decimal_places = 2,
                                  save_output_as_RDS = "no") {
  time_sequence <- seq(from = min_time_value, to = max_time_value, by = interval_length)
  time_labels <- utils::head(paste0("t", time_sequence, "to", time_sequence + interval_length), -1)

  if (is.null(current_type) ||
    length(current_type) != 1L ||
    !current_type %in% c("eEPSC", "sEPSC")) {
    cli::cli_abort(c("x" = "'current_type' argument must be either 'eEPSC' or 'sEPSC'"))
  }

  if (!software %in% c("Clampfit", "MiniAnalysis")) {
    cli::cli_abort(c("x" = "'software' argument must be either 'Clampfit' or 'MiniAnalysis'"))
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`save_output_as_RDS` argument must be one of: \"yes\" or \"no\""))
  }

  if (!is.numeric(decimal_places)) {
    cli::cli_abort(c("x" = "`decimal_places` argument must be numeric"))
  }

  # Prune within individual cells
  pruned_df_individual_cells <- data %>%
    dplyr::mutate(
      interval_pruned = cut(
        .data$time,
        breaks = time_sequence,
        include.lowest = TRUE,
        labels = time_labels
      )
    ) %>%
    dplyr::group_by(
      .data$category,
      .data$letter,
      .data$sex,
      .data$treatment,
      .data$interval_pruned
    )

  if (current_type == "eEPSC") {
    pruned_df_individual_cells <- pruned_df_individual_cells %>%
      dplyr::reframe(
        mean_P1 = mean(.data$P1, na.rm = TRUE),
        # Mean amplitude per minute across all cells
        sd_P1 = stats::sd(.data$P1, na.rm = TRUE),
        n = dplyr::n(),
        se = .data$sd_P1 / sqrt(.data$n),
        cv = .data$sd_P1 / .data$mean_P1,
        cv_inverse_square = 1 / (.data$cv^2),
        letter = unique(.data$letter),
        category = unique(.data$category),
        time = max(.data$time),
        baseline_mean = unique(.data$baseline_mean),
        synapses = unique(.data$synapses),
        days_alone = unique(.data$days_alone),
        animal_or_slicing_problems = unique(.data$animal_or_slicing_problems)
      ) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))


    pruned_df_for_table <- pruned_df_individual_cells %>%
      dplyr::group_by(.data$letter) %>%
      dplyr::summarize(P1_transformed = list(.data$mean_P1))
  }

  if (current_type == "sEPSC") {
    if (software == "Clampfit") {
      pruned_df_individual_cells <- pruned_df_individual_cells %>%
        dplyr::reframe(
          mean_amplitude = mean(.data$amplitude_transformed, na.rm = TRUE),
          mean_raw_amplitude = mean(.data$amplitude, na.rm = TRUE),
          sd_amplitude = stats::sd(.data$amplitude_transformed, na.rm = TRUE),
          n = dplyr::n(),
          # Gets number of currents within each minute
          frequency = .data$n / (60 * interval_length),
          # Frequency in Hz
          se = .data$sd_amplitude / sqrt(.data$n),
          letter = unique(.data$letter),
          category = unique(.data$category),
          interval = dplyr::first(.data$interval),
          synapses = unique(.data$synapses),
          days_alone = unique(.data$days_alone),
          animal_or_slicing_problems = unique(.data$animal_or_slicing_problems),
          time = max(.data$time) # Time at interval end; used for plots
        ) %>%
        dplyr::group_by(.data$letter) %>%
        # Obtain normalized frequency
        dplyr::mutate(
          baseline_range = (.data$time <= baseline_length),
          baseline_mean_frequency = sum(.data$frequency * .data$baseline_range) / sum(.data$baseline_range),
          frequency_transformed = (.data$frequency / .data$baseline_mean_frequency) * 100
        ) %>%
        dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))
    }



    if (software == "MiniAnalysis") {
      pruned_df_individual_cells <- pruned_df_individual_cells %>%
        dplyr::reframe(
          mean_amplitude = mean(.data$amplitude_transformed, na.rm = TRUE),
          mean_raw_amplitude = mean(.data$amplitude, na.rm = TRUE),
          sd_amplitude = stats::sd(.data$amplitude_transformed, na.rm = TRUE),
          n = dplyr::n(),
          frequency = mean(.data$frequency),
          se = .data$sd_amplitude / sqrt(.data$n),
          letter = unique(.data$letter),
          category = unique(.data$category),
          interval = dplyr::first(.data$interval),
          synapses = unique(.data$synapses),
          days_alone = unique(.data$days_alone),
          animal_or_slicing_problems = unique(.data$animal_or_slicing_problems),
          time = max(.data$time) # Time at interval end; used for plots
        ) %>%
        dplyr::group_by(.data$letter) %>%
        # Obtain normalized frequency
        dplyr::mutate(
          baseline_range = (.data$time <= baseline_length),
          baseline_mean_frequency = sum(.data$frequency * .data$baseline_range) / sum(.data$baseline_range),
          frequency_transformed = (.data$frequency / .data$baseline_mean_frequency) * 100
        ) %>%
        dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))
    }

    pruned_df_for_table <- pruned_df_individual_cells %>%
      dplyr::group_by(.data$letter) %>%
      dplyr::summarize(spont_amplitude_transformed = list(.data$mean_amplitude))
  }


  # Prune all cells
  if (current_type == "eEPSC") {
    pruned_df_all_cells <- data %>%
      dplyr::mutate(
        interval_pruned = cut(
          .data$time,
          breaks = time_sequence,
          include.lowest = TRUE,
          labels = time_labels
        )
      ) %>%
      dplyr::group_by(
        .data$category,
        .data$letter,
        .data$sex,
        .data$treatment,
        .data$interval_pruned
      ) %>%
      dplyr::reframe(
        mean_P1 = mean(.data$P1_transformed, na.rm = TRUE),
        sd_P1 = stats::sd(.data$P1_transformed, na.rm = TRUE),
        n = dplyr::n(),
        se = .data$sd_P1 / sqrt(.data$n),
        cv = .data$sd_P1 / .data$mean_P1 * 100,
        letter = unique(.data$letter),
        category = unique(.data$category),
        time = max(.data$time)
      ) %>%
      dplyr::group_by(
        .data$category,
        .data$interval_pruned,
        .data$sex,
        .data$treatment
      ) %>%
      dplyr::reframe(
        mean_P1_all_cells = mean(.data$mean_P1, na.rm = TRUE),
        sd_P1_all_cells = stats::sd(.data$mean_P1, na.rm = TRUE),
        n = dplyr::n(),
        se_P1_all_cells = .data$sd_P1_all_cells / sqrt(.data$n),
        cv_P1_all_cells = .data$sd_P1_all_cells / .data$mean_P1_all_cells * 100,
        time = max(.data$time),
        category = unique(.data$category),
      ) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))
  }

  if (current_type == "sEPSC") {
    pruned_df_all_cells <- pruned_df_individual_cells %>%
      dplyr::ungroup() %>%
      dplyr::group_by(
        .data$category,
        .data$interval_pruned,
        .data$sex,
        .data$treatment
      ) %>%
      dplyr::reframe(
        mean_all_amplitude = mean(.data$mean_amplitude, na.rm = TRUE),
        mean_all_raw_amplitude = mean(.data$mean_raw_amplitude, na.rm = TRUE),
        sd_all_amplitude = stats::sd(.data$mean_amplitude, na.rm = TRUE),
        n = dplyr::n(),
        se_amplitude = .data$sd_all_amplitude / sqrt(.data$n),
        sd_all_raw_amplitude = stats::sd(.data$mean_raw_amplitude, na.rm = TRUE),
        se_raw_amplitude = .data$sd_all_raw_amplitude / sqrt(.data$n),
        mean_all_frequency = mean(.data$frequency_transformed, na.rm = TRUE),
        sd_all_frequency = stats::sd(.data$frequency_transformed, na.rm = TRUE),
        se_frequency = .data$sd_all_frequency / sqrt(.data$n),
        mean_all_raw_frequency = mean(.data$frequency, na.rm = TRUE),
        sd_all_raw_frequency = stats::sd(.data$frequency, na.rm = TRUE),
        se_raw_frequency = .data$sd_all_raw_frequency / sqrt(.data$n),
        time = max(.data$time),
        interval = unique(.data$interval),
        category = unique(.data$category)
      ) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))
  }

  pruned_data_final <- list(
    individual_cells = pruned_df_individual_cells,
    for_table = pruned_df_for_table,
    all_cells = pruned_df_all_cells
  )

  if (save_output_as_RDS == "yes") {
    RDS_path <- "Data/Output-Data-from-R/"

    if (!dir.exists(here::here(RDS_path))) {
      dir.create(here::here(RDS_path), recursive = TRUE)

      cli::cli_alert_success(cli::col_green(paste0("Created new folder called ", RDS_path)))
    }

    saveRDS(pruned_data_final, file = here::here(
      paste0(
        RDS_path,
        "pruned_",
        current_type,
        "_data.rds"
      )
    ))
  }

  return(pruned_data_final)
}

#' Summarize current data per 5-min for statistical tests
#'
#' `make_summary_EPSC_data()` allows you to divide data from a long recording
#' (e.g. 30 minutes) into evenly-spaced intervals (e.g. 5 minutes). It will
#' generate summary data like the mean current amplitude for each interval. This
#' can be useful for inserting into statistical models to compare effect sizes
#' across broad stretches of time. The interval length would have been
#' previously specified in [make_normalized_EPSC_data()] using the
#' `interval_length` argument.
#'
#' @inheritParams make_pruned_EPSC_data
#' @param data A `data.frame` object. If the data are evoked currents
#'   (`current_type == "eEPSC"`), this should be the raw evoked current data
#'   generated using [make_normalized_EPSC_data()]. If the data are spontaneous
#'   currents (`current_type == "sEPSC"`), this should be the pruned data
#'   `$individual_cells` dataset generated using [make_pruned_EPSC_data()].
#' @param ending_interval A character value describing the last interval in the recording. Useful for future plots in which you compare the percent decrease/increase in current amplitude relative to the baseline. Examples include `"t20to25"`, `"t10to15"`, etc.
#' @param baseline_interval A character value describing the baseline interval. Defaults to `"t0to5"`.
#'
#' @returns A list of three dataframes (`current_type = eEPSC`) or three dataframes (`current_type = sEPSC`). For evoked currents (`current_type = "eEPSC"`) the first dataframe (`$percent_change_data`) contains the mean current amplitude for each interval, with a final column (`percent_change`) containing the final percent change in amplitude in the last interval relative to the mean amplitude during the baseline interval.
#'
#' Most columns (`age`, `sex`, `animal`, etc.) come directly from the information imported through `import_cell_characteristics_df()`. However, there are some new columns of note.
#'
#' \itemize{
#' \item `t0to5` The mean evoked current amplitude (pA) for this cell during the period of 0 to 5 minutes.
#'  \item `t5to10` The mean evoked current amplitude (pA) for this cell during the period of 5 to 10 minutes.
#'  \item `t10to15`, `t15to20`, `tXtY` etc... The mean evoked current amplitude (pA) for this cell during the period of *X* to *Y* minutes.
#'  \item `percent_change` The percent change in evoked current amplitude in the interval `t20to25` as a percentage of the mean baseline amplitude (`t0to5`). For example, if currents began at 100 pA during the baseline period, but were 50 pA by `t20to25`, the value of `percent_change` will be `50%` or `0.50`. You can also change the value of the intervals used in this calculation through the `baseline_interval` and `ending_interval` arguments.
#' }
#'
#' The second dataframe (accessed through `$summary_data`) contains summary data such as the mean current amplitude,
#'   coefficient of variation, standard deviation, standard error, variance,
#'   variance-to-mean ratio, and inverse coefficient of variation squared for
#'   each interval.
#'
#'   New columns for evoked current data (`current_type == "eEPSC"`) include:
#'  \itemize{
#'  \item `mean_P1_transformed` The amplitude of the first evoked current
#'  amplitude (% Baseline eEPSC amplitude) normalized to the mean baseline
#'  amplitude and averaged over the interval.
#'  \item `mean_P1_raw` The amplitude of the first evoked current amplitude (pA) averaged over the interval.
#'  \item `n` The number of datapoints used to create the averaged values.
#'  Corresponds to the number of sweeps per interval.
#'  \item `sd` The standard deviation of the normalized evoked current data
#'  (`P1_transformed`).
#'  \item `cv` The coefficient of variation of `P1_transformed`.
#'  \item `se` The standard error of `P1_transformed`.
#'  \item `cv_inverse_square` The inverse of the squared coefficient of
#'  variation of `P1_transformed`.
#'  \item `variance` The variance of `P1_transformed`.
#'  \item `VMR` The variance-to-mean ratio (VMR) of `P1_transformed`.
#'  \item `interval` A character value indicating the interval that the data
#'  point belongs to. For example, `interval` will be "t0to5" for any data
#'  points from 0 to 5 minutes. Example values: "t0to5", "t5to10", etc.
#'  \item `letter, synapses, sex, treatment, etc.` Unmodified columns from the
#'  original dataset describing the cell's properties.
#' }
#'
#' The third dataframe (accessed with `$mean_SE`) contains summary statistics that will be useful for publications. It presents mean evoked current amplitudes (taken from raw `P1` values) grouped by category, treatment, and sex. This will make it easy to report your findings as *mean +/- SE or SD* with *n* in publications. For example, "eEPSC amplitude decreased significantly in males (baseline: 24.1 +/- 0.11 pA, n = 6, insulin: 12.4 +/- 0.23 pA, n = 7)."
#'
#' \itemize{
#'  \item `category` The experiment category (please see `import_cell_characteristics_df()` for more details).
#'  \item `sex` The sex of the animal
#'  \item `treatment` The treatment applied.
#'  \item `n` The number of data points (i.e. cells)
#'  \item `mean_baseline_raw_P1` The average evoked current amplitude (taken from `mean_P1_raw`) during the `baseline_interval`.
#'  \item `sd_baseline_raw_P1` The standard deviation of `mean_baseline_raw_P1.`
#'  \item `se_baseline_raw_P1` The standard error of `mean_baseline_raw_P1`. Taken by dividing `sd_baseline_raw_P1` by the square root of `n`.
#'  \item `mean_ending_raw_P1` The average evoked current amplitude (taken from `mean_P1_raw`) during the `ending_interval`.
#'  \item `sd_ending_raw_P1` The standard deviation of `mean_ending_raw_P1.`
#'  \item `se_ending_raw_P1` The standard error of `mean_ending_raw_P1`. Taken by dividing `sd_ending_raw_P1` by the square root of `n`.
#'
#'  \item `VMR` The variance-to-mean ratio (VMR) of `P1_transformed`.
#'  \item `interval` A character value indicating the interval that the data
#'  point belongs to. For example, `interval` will be "t0to5" for any data
#'  points from 0 to 5 minutes. Example values: "t0to5", "t5to10", etc.
#'  \item `letter, synapses, sex, treatment, etc.` Unmodified columns from the
#'  original dataset describing the cell's properties.
#' }
#'
#'
#' ## Spontaneous Current Data
#'
#' Spontaneous current data results in five dataframes. The first dataframe ($summary_data) contains summary statistics for each interval, as outlined below:
#'
#' \itemize{
#'  \item `mean_transformed_amplitude` The average normalized spontaneous
#'  current amplitude (% Baseline sEPSC amplitude).
#'  \item `mean_raw_amplitude` The average raw spontaneous current amplitude
#'  (pA).
#'  \item `n` The number of datapoints used to create the average.
#'  \item `sd_transformed_amplitude` The standard deviation of the normalized
#'  spontaneous current data (`mean_transformed_amplitude`).
#'  \item `se_transformed_amplitude` The standard error of
#'  `mean_transformed_amplitude`.
#'  \item `mean_transformed_frequency` The average normalized frequency (%
#'  Baseline frequency).
#'  \item `sd_transformed_frequency` The standard deviation of `mean_transformed_frequency`.
#'  \item `se_frequency` The standard error of `mean_transformed_frequency`.
#'  \item `mean_raw_frequency` The average raw frequency (Hz).
#'  \item `letter, synapses, sex, treatment, etc.` Unmodified columns from the
#'  original dataset describing the cell's properties.
#' }
#'
#' The second and third dataframes contain percent change data for spontaneous current amplitude and frequency, respectively. The columns are the same as the ones produced for evoked currents (read the documentation for `$percent_change_data`.
#'
#' The fourth and fifth dataframes contain the mean, SE, SD, and n data for spontaneous current amplitude and frequency, respectively. Read the description for the `$mean_SE` to learn about these columns.
#'
#' @export
#'
#' @examples
#'
#' # Evoked Currents
#' # Will return a list of three dataframes
#'
#' make_summary_EPSC_data(
#'   data = sample_raw_eEPSC_df,
#'   current_type = "eEPSC",
#'   save_output_as_RDS = "no",
#'   decimal_places = 2
#' )
#'
#' # Spontaneous Data
#' # Will return a list of three dataframes
#'
#' make_summary_EPSC_data(
#'   data = sample_pruned_sEPSC_df$individual_cells,
#'   current_type = "sEPSC",
#'   save_output_as_RDS = "no",
#'   decimal_places = 2,
#'   baseline_interval = "t0to5",
#'   ending_interval = "t20to25"
#' )
#'
make_summary_EPSC_data <- function(data = patchclampplotteR::sample_raw_eEPSC_df,
                                   current_type = "eEPSC",
                                   save_output_as_RDS = "no",
                                   decimal_places = 2,
                                   baseline_interval = "t0to5",
                                   ending_interval = "t20to25") {
  if (is.null(current_type) ||
    length(current_type) != 1L ||
    !current_type %in% c("eEPSC", "sEPSC")) {
    cli::cli_abort(c("x" = "'current_type' argument must be either 'eEPSC' or 'sEPSC'"))
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`save_output_as_RDS` argument must be one of: \"yes\" or \"no\""))
  }

  if (!is.numeric(decimal_places)) {
    cli::cli_abort(c("x" = "`decimal_places` argument must be numeric"))
  }

  if (current_type == "eEPSC") {
    summary_df <- data %>%
      dplyr::group_by(
        .data$category,
        .data$letter,
        .data$sex,
        .data$treatment,
        .data$interval
      )

    summary_df <- summary_df %>%
      dplyr::summarize(
        mean_P1_transformed = mean(.data$P1_transformed, na.rm = TRUE),
        mean_P1_raw = mean(.data$P1, na.rm = TRUE),
        n = dplyr::n(),
        sd = stats::sd(.data$P1_transformed, na.rm = TRUE),
        cv = .data$sd / .data$mean_P1_transformed,
        se = .data$sd / sqrt(.data$n),
        cv_inverse_square = 1 / (.data$cv^2),
        variance = stats::var(.data$P1_transformed, na.rm = TRUE),
        VMR = .data$variance / .data$mean_P1_transformed,
        age = unique(.data$age),
        # unique() retains unmodified columns that still should be included
        animal = unique(.data$animal),
        X = unique(.data$X),
        Y = unique(.data$Y),
        time = max(.data$time),
        synapses = unique(.data$synapses),
        days_alone = unique(.data$days_alone),
        animal_or_slicing_problems = unique(.data$animal_or_slicing_problems)
      ) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))


    percent_change_df <- summary_df %>%
      dplyr::group_by(.data$category, .data$treatment, .data$interval, .data$letter) %>%
      dplyr::select(!c(
        .data$se,
        .data$cv,
        .data$sd,
        .data$n,
        .data$cv_inverse_square,
        .data$variance,
        .data$VMR,
        .data$time,
        .data$mean_P1_transformed
      )) %>%
      tidyr::pivot_wider(names_from = .data$interval, values_from = .data$mean_P1_raw) %>%
      dplyr::mutate(percent_change = .data[[ending_interval]] / .data[[baseline_interval]] *
        100) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))


    mean_and_SE_df <- percent_change_df %>%
      dplyr::group_by(.data$category, .data$treatment, .data$sex) %>%
      dplyr::summarize(
        n = dplyr::n(),
        mean_baseline_raw_P1 = mean(.data[[baseline_interval]], na.rm = T),
        sd_baseline_raw_P1 = sd(.data[[baseline_interval]], na.rm = T),
        se_baseline_raw_P1 = .data$sd_baseline_raw_P1 / sqrt(.data$n),
        mean_ending_raw_P1 = mean(.data[[ending_interval]], na.rm = T),
        sd_ending_raw_P1 = sd(.data[[ending_interval]], na.rm = T),
        se_ending_raw_P1 = .data$sd_ending_raw_P1 / sqrt(.data$n)
      )

    summary_data_final <- list(
      percent_change_data = percent_change_df,
      summary_data = summary_df,
      mean_SE = mean_and_SE_df
    )
  }


  if (current_type == "sEPSC") {
    summary_df <- data %>%
      dplyr::group_by(
        .data$category,
        .data$letter,
        .data$sex,
        .data$treatment,
        .data$interval
      )

    summary_df <- summary_df %>%
      dplyr::summarize(
        mean_transformed_amplitude = mean(.data$mean_amplitude, na.rm = TRUE),
        mean_raw_amplitude = mean(.data$mean_raw_amplitude, na.rm = TRUE),
        sd_transformed_amplitude = stats::sd(.data$mean_amplitude, na.rm = TRUE),
        n = dplyr::n(),
        se_transformed_amplitude = .data$sd_transformed_amplitude / sqrt(.data$n),
        mean_transformed_frequency = mean(.data$frequency_transformed, na.rm = TRUE),
        sd_transformed_frequency = stats::sd(.data$frequency_transformed, na.rm = TRUE),
        se_transformed_frequency = .data$sd_transformed_frequency / sqrt(.data$n),
        mean_raw_frequency = mean(.data$frequency, na.rm = TRUE),
        time = max(.data$time),
        interval = unique(.data$interval),
        category = unique(.data$category),
        synapses = dplyr::last(.data$synapses),
        days_alone = unique(.data$days_alone),
        animal_or_slicing_problems = unique(.data$animal_or_slicing_problems)
      ) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), \(x) round(x, decimal_places)))


    # Percent change in sEPSC Amplitude
    percent_change_amplitude_df <- summary_df %>%
      dplyr::group_by(.data$category, .data$treatment, .data$interval, .data$letter) %>%
      dplyr::select(
        !c(
          .data$mean_transformed_amplitude,
          .data$sd_transformed_amplitude,
          .data$se_transformed_amplitude,
          .data$mean_transformed_frequency,
          .data$sd_transformed_frequency,
          .data$se_transformed_frequency,
          .data$mean_raw_frequency,
          .data$time,
          .data$n
        )
      ) %>%
      tidyr::pivot_wider(
        names_from = .data$interval,
        values_from = .data$mean_raw_amplitude
      ) %>%
      dplyr::mutate(percent_change = .data[[ending_interval]] / .data[[baseline_interval]] * 100) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), function(x) {
        round(x, decimal_places)
      }))


    # Percent change in sEPSC Frequency

    percent_change_frequency_df <- summary_df %>%
      dplyr::group_by(.data$category, .data$treatment, .data$interval, .data$letter) %>%
      dplyr::select(
        !c(
          .data$mean_transformed_amplitude,
          .data$sd_transformed_amplitude,
          .data$se_transformed_amplitude,
          .data$mean_transformed_frequency,
          .data$sd_transformed_frequency,
          .data$se_transformed_frequency,
          .data$mean_raw_amplitude,
          .data$time,
          .data$n
        )
      ) %>%
      tidyr::pivot_wider(
        names_from = .data$interval,
        values_from = .data$mean_raw_frequency
      ) %>%
      dplyr::mutate(percent_change = .data[[ending_interval]] / .data[[baseline_interval]] * 100) %>%
      dplyr::mutate(dplyr::across(dplyr::where(is.numeric), function(x) {
        round(x, decimal_places)
      }))


    mean_and_SE_df_amplitude_df <- percent_change_amplitude_df %>%
      dplyr::group_by(.data$category, .data$treatment, .data$sex) %>%
      dplyr::summarize(
        n = dplyr::n(),
        mean_baseline_amplitude = mean(.data[[baseline_interval]],
          na.rm =
            T
        ),
        sd_baseline_amplitude = sd(.data[[baseline_interval]],
          na.rm =
            T
        ),
        se_baseline_amplitude = .data$sd_baseline_amplitude / sqrt(.data$n),
        mean_ending_amplitude = mean(.data[[ending_interval]],
          na.rm =
            T
        ),
        sd_ending_amplitude = sd(.data[[ending_interval]],
          na.rm =
            T
        ),
        se_ending_amplitude = .data$sd_ending_amplitude / sqrt(.data$n)
      )

    mean_and_SE_df_frequency_df <- percent_change_frequency_df %>%
      dplyr::group_by(.data$category, .data$treatment, .data$sex) %>%
      dplyr::summarize(
        n = dplyr::n(),
        mean_baseline_frequency = mean(.data[[baseline_interval]],
          na.rm =
            T
        ),
        sd_baseline_frequency = sd(.data[[baseline_interval]],
          na.rm =
            T
        ),
        se_baseline_frequency = .data$sd_baseline_frequency / sqrt(.data$n),
        mean_ending_frequency = mean(.data[[ending_interval]],
          na.rm =
            T
        ),
        sd_ending_frequency = sd(.data[[ending_interval]],
          na.rm =
            T
        ),
        se_ending_frequency = .data$sd_ending_frequency / sqrt(.data$n)
      )

    summary_data_final <- list(
      summary_data = summary_df,
      percent_change_amplitude = percent_change_amplitude_df,
      percent_change_frequency = percent_change_frequency_df,
      mean_SE_amplitude = mean_and_SE_df_amplitude_df,
      mean_SE_frequency = mean_and_SE_df_frequency_df
    )
  }

  if (save_output_as_RDS == "yes") {
    RDS_path <- "Data/Output-Data-from-R/"

    if (!dir.exists(here::here(RDS_path))) {
      dir.create(here::here(RDS_path), recursive = TRUE)

      cli::cli_alert_success(cli::col_green(paste0("Created new folder called ", RDS_path)))

      saveRDS(summary_data_final, file = here::here(
        paste0(
          RDS_path,
          "summary_",
          current_type,
          "_data.rds"
        )
      ))
    } else {
      saveRDS(summary_data_final, file = here::here(
        paste0(
          RDS_path,
          "summary_",
          current_type,
          "_data.rds"
        )
      ))
    }
  }

  return(summary_data_final)
}


#' Perform t-tests (or Wilcoxon tests) for EPSC summary plots
#'
#' This function enables you to perform a series of paired t-tests (or Wilcoxon tests) comparing the
#' mean current amplitude within each interval relative to the mean current
#' amplitude during the baseline. This uses the `pairwise_t_test` or `pairwise_wilcox_test` functions from
#' `rstatix`, with `paired = TRUE` and Holm's adjustment for multiple
#' comparisons (`p_adjust_method = "holm"`) by default. The resulting output table can also
#' be used to apply significance stars to the plot in
#' [plot_summary_current_data()].
#'
#' @inheritParams plot_baseline_data
#' @inheritParams make_normalized_EPSC_data
#' @param p_adjust_method This argument is directly related to `p.adjust.method` in `rstatix::t_test`. This is the method used to adjust the p-value in multiple pairwise comparisons. Allowed values include `"holm"`, `"hochberg"`, `"hommel"`, `"bonferroni"`, `"BH"`, `"BY"`, `"fdr"`, `"none"` (although `"none"` is NOT recommended).
#' @param include_all_categories A character (`"yes"` or `"no"`) specifying if the
#'   table will include data from all categories. If `"no"`, you must specify a
#'   list of categories in `list_of_categories`.
#' @param list_of_categories A list of character values describing the
#'   categories that will be in the table. Defaults to `NULL`, since
#'   `include_all_categories` is `"yes"` by default.
#' @param test_type A character (must be `"pairwise.wilcox.test"` or `"pairwise.t.test"`)
#'   describing the statistical model used in this function.
#' @param parameter A character value specifying the parameter to be plotted on
#'   the y-axis. For evoked currents (`current_type = "eEPSC"`), the available
#'   parameter is "amplitude", which contains amplitudes normalized relative to
#'   the baseline. For spontaneous currents (`current_type = "sEPSC"`), the
#'   available parameters are "amplitude" (normalized currents),
#'   "raw_amplitude", "frequency" (normalized frequency) or "raw_frequency".
#'
#' @returns A dataframe
#' @export
#'
#' @references Nutter B (2018). _lazyWeave: LaTeX Wrappers for R #' Users_. R package version
#' 3.0.2, <https://CRAN.R-project.org/package=lazyWeave>.
#'
#' @seealso [make_normalized_EPSC_data()] for an example of how the normalized
#'   current amplitudes were created.
#'
#' @examples
#' perform_t_tests_for_summary_plot(
#'   data = sample_summary_eEPSC_df$summary_data,
#'   include_all_treatments = "yes",
#'   list_of_treatments = NULL,
#'   current_type = "eEPSC",
#'   parameter = "amplitude",
#'   baseline_interval = "t0to5",
#'   test_type = "pairwise.t.test",
#'   interval_length = 5,
#'   treatment_colour_theme = sample_treatment_names_and_colours,
#'   save_output_as_RDS = "no"
#' )
perform_t_tests_for_summary_plot <- function(data,
                                             include_all_treatments = "yes",
                                             list_of_treatments = NULL,
                                             include_all_categories = "yes",
                                             list_of_categories = NULL,
                                             current_type = "eEPSC",
                                             parameter = "amplitude",
                                             baseline_interval = "t0to5",
                                             interval_length = 5,
                                             treatment_colour_theme,
                                             test_type = "pairwise.t.test",
                                             p_adjust_method = "holm",
                                             save_output_as_RDS = "no") {
  if (is.null(current_type) ||
    length(current_type) != 1L ||
    !current_type %in% c("eEPSC", "sEPSC")) {
    cli::cli_abort(c("x" = "'current_type' argument must be either 'eEPSC' or 'sEPSC'"))
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`save_output_as_RDS` argument must be one of: \"yes\" or \"no\""))
  }

  if (!test_type %in% c("pairwise.wilcox.test", "pairwise.t.test")) {
    cli::cli_abort(c("x" = "'test_type' argument must be one of: \"pairwise.wilcox.test\" or \"pairwise.t.test\""))
  }

  if (!include_all_treatments %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`include_all_treatments` must be either \"yes\" or \"no\"."))
  }

  if (!include_all_categories %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`include_all_categories` must be either \"yes\" or \"no\"."))
  }

  if (!p_adjust_method %in% c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")) {
    cli::cli_abort(c("x" = "`p_adjust_method` argument must be one of: \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", \"fdr\", or \"none\""))
  }

  treatment_info <- treatment_colour_theme
  t_test_data <- data

  if (include_all_categories == "yes") {
    if (!is.null(list_of_categories)) {
      cli::cli_alert_info(
        "include_all_categories = \"yes\", but you included a list of categories to filter. All categories will be used."
      )
    }
  } else {
    if (is.null(list_of_categories)) {
      cli::cli_abort(c(
        "x" = paste0(
          "`include_all_categories` = \"",
          include_all_categories,
          "\", but `list_of_categories` is NULL."
        ),
        "i" = "Did you forget to add a list of categories?"
      ))
    }

    treatment_info <- treatment_info %>%
      dplyr::filter(.data$category %in% list_of_categories)
    t_test_data <- t_test_data %>%
      dplyr::filter(.data$category %in% list_of_categories) %>%
      droplevels()
  }


  if (include_all_treatments == "yes") {
    if (!is.null(list_of_treatments)) {
      cli::cli_alert_info(
        "include_all_treatments = \"yes\", but you included a list of treatments to filter. All treatments will be used."
      )
    }
  } else {
    if (is.null(list_of_treatments)) {
      cli::cli_abort(c(
        "x" = paste0(
          "`include_all_treatments` = \"",
          include_all_treatments,
          "\", but `list_of_treatments` is NULL."
        ),
        "i" = "Did you forget to add a list of treatments?"
      ))
    }

    if (!is.character(list_of_treatments)) {
      cli::cli_abort(c(
        "x" = paste0(
          "`include_all_treatments` = \"",
          include_all_treatments,
          "\", but `list_of_treatments` is not a character object or list of characters."
        ),
        "i" = "Did you forget to add a list of treatments?"
      ))
    }

    if (is.null(baseline_interval) ||
      !is.character(baseline_interval)) {
      cli::cli_abort(c("x" = "`baseline_interval` must be a character (e.g. \"t0to5\", \"t0to3\")"))
    }

    treatment_info <- treatment_info %>%
      dplyr::filter(.data$treatment %in% list_of_treatments)
    t_test_data <- t_test_data %>%
      dplyr::filter(.data$treatment %in% list_of_treatments) %>%
      droplevels()
  }

  if (current_type == "eEPSC") {
    allowed_parameters_list <- "\"amplitude\""

    if (!parameter %in% c("amplitude")) {
      cli::cli_abort(c(
        "x" = paste0(
          "`parameter` must be ",
          allowed_parameters_list,
          " for current_type \"",
          current_type,
          "\"."
        ),
        "i" = "Check that you have the correct combination of `parameter`, `current_type` and `data.`"
      ))
    }

    if (parameter == "amplitude") {
      if (test_type == "pairwise.t.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_t_test(
            mean_P1_transformed ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }

      if (test_type == "pairwise.wilcox.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_wilcox_test(
            mean_P1_transformed ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }
    }
  }

  if (current_type == "sEPSC") {
    allowed_parameters_list <- "\"amplitude\", \"raw_amplitude\", \"raw_frequency\", or \"frequency\""

    if (!parameter %in% c(
      "amplitude",
      "raw_amplitude",
      "frequency",
      "raw_frequency"
    )) {
      cli::cli_abort(c(
        "x" = paste0(
          "`parameter` must be ",
          allowed_parameters_list,
          " for current_type \"",
          current_type,
          "\"."
        ),
        "i" = "Check that you have the correct combination of `parameter`, `current_type` and `data.`"
      ))
    }

    if (parameter == "amplitude") {
      if (test_type == "pairwise.t.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_t_test(
            mean_transformed_amplitude ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }

      if (test_type == "pairwise.wilcox.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_wilcox_test(
            mean_transformed_amplitude ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }
    }

    if (parameter == "raw_amplitude") {
      if (test_type == "pairwise.t.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_t_test(
            mean_raw_amplitude ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }

      if (test_type == "pairwise.wilcox.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_wilcox_test(
            mean_raw_amplitude ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }
    }

    if (parameter == "frequency") {
      if (test_type == "pairwise.t.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_t_test(
            mean_transformed_frequency ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }

      if (test_type == "pairwise.wilcox.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_wilcox_test(
            mean_transformed_frequency ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }
    }

    if (parameter == "raw_frequency") {
      if (test_type == "pairwise.t.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_t_test(
            mean_raw_frequency ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }
      if (test_type == "pairwise.wilcox.test") {
        t_test_results <- t_test_data %>%
          dplyr::group_by(.data$category, .data$treatment) %>%
          rstatix::pairwise_wilcox_test(
            mean_raw_frequency ~ interval,
            ref.group = baseline_interval,
            paired = TRUE,
            p.adjust.method = p_adjust_method
          )
      }
    }
  }

  t_test_table <- t_test_results %>%
    dplyr::mutate(
      statistic = round(.data$statistic, 2),
      p_string = pvalString(.data$p.adj),
      significance_stars = dplyr::case_when(.data$p.adj.signif == "ns" ~ "", T ~ .data$p.adj.signif)
    )

  if (test_type == "pairwise.wilcox.test") {
    t_test_table <- t_test_table %>%
      dplyr::mutate(
        df = .data$n1 - 1
      )
  }

  # Need sequence of integers from 1 to the maximum number of intervals
  # to generate asterisk_time as a function of the number of intervals
  integer_sequence <- seq(1, length(unique(t_test_table$group2)), by = 1)

  positions_df <- data.frame(
    group2 = unique(t_test_table$group2),
    asterisk_time = (interval_length / 2) + interval_length * integer_sequence
  )

  t_test_table <- merge(positions_df, t_test_table, by = "group2") %>%
    dplyr::arrange(match(.data$treatment, treatment_info$treatment))

  t_test_table <- t_test_table %>%
    dplyr::group_by(.data$category, .data$treatment) %>%
    dplyr::arrange(.data$asterisk_time, .by_group = TRUE)

  if (save_output_as_RDS == "yes") {
    RDS_path <- "Data/Output-Data-from-R/"

    if (!dir.exists(here::here(RDS_path))) {
      dir.create(here::here(RDS_path), recursive = TRUE)

      cli::cli_alert_success(cli::col_green(paste0("Created new folder called ", RDS_path)))
    }

    saveRDS(t_test_table, file = here::here(
      paste0(RDS_path, "t_test_", current_type, ".rds")
    ))
  }

  return(t_test_table)
}



#' Make dataframe with variance measures
#'
#' `make_variance_data` creates a dataframe containing variance measures at two
#' time points. They are the baseline period and a user-specified interval after
#' a hormone or protocol has been applied. The variance measures are the inverse
#' coefficient of variation squared and the variance-to-mean ratio (VMR). A
#' `"before vs. after"` comparison of these two variance measures is useful to
#' determine which mechanism is involved in modifying synaptic plasticity. For
#' more information, please see [Huijstee & Kessels
#' (2020)](https://doi.org/10.1016/j.jneumeth.2019.108526).
#'
#' @inheritParams plot_baseline_data
#' @inheritParams make_normalized_EPSC_data
#' @param df_category A numeric value describing the experimental category. In
#'   the sample dataset for this package, 2 represents experiments where insulin
#'   was applied continuously after a 5-minute baseline period. Here,
#'   `plot_treatment` represents antagonists that were present on the brain
#'   slice, or the animals were fasted, etc.
#' @param post_hormone_interval A character value indicating the name of the
#'   interval used as "after" timepoint for comparison. Defaults to `"t20to25"`,
#'   but can be changed. Make sure that this matches an interval present in
#'   `data`
#'
#' @returns A dataframe containing all of the columns within the summary data
#'   (see [sample_summary_eEPSC_df] for a detailed description of these columns)
#'   plus three additional columns:
#' \itemize{
#' \item `state` A character value describing if a data point belongs to the
#' baseline interval (`"Baseline"`) or an interval after a hormone or protocol has
#' been applied (`"Post-modification"`). These intervals are selected from
#' `baseline_interval` and `post_hormone_interval`.
#'  \item `mean_cv_inverse_square` The mean inverse coefficient of variation
#'  squared within a specific state and sex.
#'  \item `mean_VMR` The mean variance-to-mean ratio within a specific state and sex.
#' }
#'
#' @export
#'
#' @seealso [plot_variance_comparison_data()] to plot this data.
#'
#' @examples
#'
#' make_variance_data(
#'   data = sample_summary_eEPSC_df$summary_data,
#'   df_category = 2,
#'   include_all_treatments = "yes",
#'   list_of_treatments = NULL,
#'   baseline_interval = "t0to5",
#'   post_hormone_interval = "t20to25",
#'   treatment_colour_theme = sample_treatment_names_and_colours,
#'   save_output_as_RDS = "no"
#' )
#'
make_variance_data <- function(data,
                               df_category,
                               include_all_treatments = "yes",
                               list_of_treatments = NULL,
                               baseline_interval = "t0to5",
                               post_hormone_interval = "t20to25",
                               treatment_colour_theme,
                               save_output_as_RDS = "no") {
  if (!save_output_as_RDS %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`save_output_as_RDS` argument must be one of: \"yes\" or \"no\""))
  }

  if (!include_all_treatments %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`include_all_treatments` must be either \"yes\" or \"no\"."))
  }

  if (include_all_treatments == "yes") {
    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% treatment_colour_theme$treatment) %>%
      droplevels()

    treatment_info <- treatment_colour_theme

    if (!is.null(list_of_treatments)) {
      cli::cli_alert_info(
        "include_all_treatments = \"yes\", but you included a list of treatments to filter. All treatments will be used."
      )
    }
  } else {
    if (is.null(list_of_treatments)) {
      cli::cli_abort(c(
        "x" = paste0(
          "`include_all_treatments` = \"",
          include_all_treatments,
          "\", but `list_of_treatments` is NULL."
        ),
        "i" = "Did you forget to add a list of treatments?"
      ))
    }

    if (!is.character(list_of_treatments)) {
      cli::cli_abort(c(
        "x" = paste0(
          "`include_all_treatments` = \"",
          include_all_treatments,
          "\", but `list_of_treatments` is not a character object or list of characters."
        ),
        "i" = "Did you forget to add a list of treatments?"
      ))
    }

    if (is.null(baseline_interval) ||
      !is.character(baseline_interval)) {
      cli::cli_abort(c("x" = "`baseline_interval` must be a character (e.g. \"t0to5\", \"t0to3\")"))
    }

    if (is.null(post_hormone_interval) ||
      !is.character(post_hormone_interval)) {
      cli::cli_abort(c("x" = "`post_hormone_interval` must be a character (e.g. \"t20to25\")"))
    }

    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% list_of_treatments) %>%
      droplevels()

    treatment_info <- treatment_colour_theme %>%
      dplyr::filter(.data$treatment %in% list_of_treatments)
  }



  variance_data <- dataframe %>%
    dplyr::filter(.data$category == df_category) %>%
    dplyr::filter(.data$interval == baseline_interval |
      .data$interval == post_hormone_interval) %>%
    dplyr::mutate(
      state = dplyr::case_when(
        interval == baseline_interval ~ "Baseline",
        interval == post_hormone_interval ~ "Post-modification",
        T ~ interval
      )
    ) %>%
    dplyr::group_by(.data$treatment, .data$state, .data$sex) %>%
    dplyr::mutate(
      mean_cv_inverse_square = mean(.data$cv_inverse_square),
      mean_VMR = mean(.data$VMR)
    ) %>%
    dplyr::arrange(match(.data$treatment, treatment_info$display_names))


  if (save_output_as_RDS == "yes") {
    RDS_path <- "Data/Output-Data-from-R/"

    if (!dir.exists(here::here(RDS_path))) {
      dir.create(here::here(RDS_path), recursive = TRUE)

      cli::cli_alert_success(cli::col_green(paste0("Created new folder called ", RDS_path)))
    }

    saveRDS(variance_data, file = here::here(paste0(
      RDS_path,
      "variance_data.rds"
    )))
  }

  return(variance_data)
}


#' Make paired-pulse ratio (PPR) dataframe for before vs. after comparisons
#'
#' This function filters the raw current data into data that belong to one of
#' two time points. They are the baseline period and a user-specified interval
#' after a hormone or protocol has been applied. The "before/after" comparison
#' of the paired-pulse ratio (PPR) is useful to determine which mechanism is
#' involved in modifying synaptic plasticity. For example, the PPR may be
#' related to the probability of neurotransmitter release [Oleskevich et al.,
#' 2000](https://doi.org/10.1111/j.1469-7793.2000.00513.x).
#'
#' @inheritParams plot_baseline_data
#' @inheritParams make_normalized_EPSC_data

#' @param data A dataframe containing the raw evoked current data generated from
#'   [make_normalized_EPSC_data()].
#' @param PPR_min A numeric value representing the minimum PPR value permitted
#'   in the filtered dataset. Defaults to `0`.
#' @param PPR_max A numeric value representing the maximum PPR value permitted
#'   in the filtered dataset. Defaults to `5`.
#' @param post_hormone_interval A character value specifying the interval used
#'   for the data points after a hormone or protocol was applied.
#'
#' @returns A dataframe containing all of the columns from
#'   [make_normalized_EPSC_data()], but filtered to only include PPR values
#'   between `PPR_min` and `PPR_max` within the `baseline_interval` and
#'   `post_hormone_interval`.
#'
#' @export
#'
#' @seealso [plot_PPR_data_single_treatment()] and [plot_PPR_data_multiple_treatments()]
#'
#' @examples
#'
#' make_PPR_data(
#'   data = sample_raw_eEPSC_df,
#'   include_all_treatments = "yes",
#'   list_of_treatments = NULL,
#'   PPR_min = 0,
#'   PPR_max = 5,
#'   baseline_interval = "t0to5",
#'   post_hormone_interval = "t20to25",
#'   treatment_colour_theme = sample_treatment_names_and_colours
#' )
#'
make_PPR_data <- function(data,
                          include_all_treatments = "yes",
                          list_of_treatments = NULL,
                          PPR_min = 0,
                          PPR_max = 5,
                          baseline_interval = "t0to5",
                          post_hormone_interval = "t20to25",
                          treatment_colour_theme,
                          save_output_as_RDS = "no") {
  if (!save_output_as_RDS %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`save_output_as_RDS` argument must be one of: \"yes\" or \"no\""))
  }

  if (!include_all_treatments %in% c("yes", "no")) {
    cli::cli_abort(c("x" = "`include_all_treatments` must be either \"yes\" or \"no\"."))
  }


  if (include_all_treatments == "yes") {
    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% treatment_colour_theme$treatment) %>%
      droplevels()

    treatment_info <- treatment_colour_theme

    if (!is.null(list_of_treatments)) {
      cli::cli_alert_info(
        "include_all_treatments = \"yes\", but you included a list of treatments to filter. All treatments will be used."
      )
    }
  } else {
    if (is.null(list_of_treatments)) {
      cli::cli_abort(c(
        "x" = paste0(
          "`include_all_treatments` = \"",
          include_all_treatments,
          "\", but `list_of_treatments` is NULL."
        ),
        "i" = "Did you forget to add a list of treatments?"
      ))
    }

    if (!is.character(list_of_treatments)) {
      cli::cli_abort(c(
        "x" = paste0(
          "`include_all_treatments` = \"",
          include_all_treatments,
          "\", but `list_of_treatments` is not a character object or list of characters."
        ),
        "i" = "Did you forget to add a list of treatments?"
      ))
    }

    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% list_of_treatments) %>%
      droplevels()

    treatment_info <- treatment_colour_theme %>%
      dplyr::filter(.data$treatment %in% list_of_treatments)
  }

  PPR_df <- dataframe %>%
    dplyr::filter(.data$PPR < PPR_max & .data$PPR > PPR_min) %>%
    dplyr::filter(.data$interval == baseline_interval |
      .data$interval == post_hormone_interval) %>%
    dplyr::mutate(
      state = dplyr::case_when(
        interval == baseline_interval ~ "Baseline",
        interval == post_hormone_interval ~ "Post-modification",
        T ~ interval
      )
    ) %>%
    dplyr::arrange(match(.data$treatment, treatment_info$display_names))

  if (save_output_as_RDS == "yes") {
    RDS_path <- "Data/Output-Data-from-R/"

    if (!dir.exists(here::here(RDS_path))) {
      dir.create(here::here(RDS_path), recursive = TRUE)

      cli::cli_alert_success(cli::col_green(paste0("Created new folder called ", RDS_path)))
    }

    saveRDS(PPR_df, file = here::here(paste0(
      RDS_path,
      "PPR_df.rds"
    )))
  }

  return(PPR_df)
}
