#' Import and normalize raw current data
#'
#' `make_normalized_EPSC_data()` creates a dataframe of evoked or spontaneous
#' current data from a raw .csv file. The function will create a new column
#' containing the evoked or spontaneous current amplitudes normalized relative
#' to the mean current amplitude during the baseline period. For evoked current
#' data, the function also adds a column for the paired pulse ratio (`PPR =
#' P2/P1`, where `P2` is the amplitude of the second evoked current).
#'
#' @param filename A filepath to a .csv file. See add_new_cells() for the
#'   function that will merge raw data (a .csv with 4 columns: `letter`, `ID`,
#'   `P1`, and `P2`) and a `cell-characteristics.csv` file (with columns for
#'   factors like `animal`, `age`, `sex`, `synapses`). Please see the section on
#'   "Required columns" below.
#' @param current_type A character describing the current type. Allowed values
#'   are "eEPSC" or "sEPSC".
#' @param min_time_value Minimum time value (numeric; in minutes), which
#'   defaults to 0.
#' @param max_time_value Maximum recording length (numeric; in minutes). All
#'   data points will be filtered to time values less than or equal to this
#'   value. Defaults to 25.
#' @param baseline_length Length of the baseline (numeric; in minutes). Refers
#'   to data collected before applying a hormone, antagonist, or a protocol like
#'   high frequency stimulation. Defaults to 5.
#' @param interval_length Length of each interval (numeric; in minutes). Used to
#'   divide the dataset into broad ranges for statistical analysis. Important!
#'   `max_recording_length` must be evenly divisible by `interval_length`.
#'   Defaults to 5.
#' @param negative_transform_currents A character ("yes" or "no") describing if
#'   `P1` and `P2` should be negative transformed. If "yes", the values will be
#'   multiplied by (-1).
#' @param save_output_as_RDS A character ("yes" or "no") describing if the
#'   resulting object should be saved as an RDS file in the raw data folder.
#'
#' @returns A dataframe that can be viewed and used for further analyses in R.
#'   New or modified columns include:
#'\itemize{
#'  \item `P1` (for evoked currents only) May be negative-transformed if
#'  `negative_transform` == "yes"
#'  \item `P2` (for evoked currents only) May be negative-transformed if
#'  `negative_transform` == "yes"
#'  \item `PPR` (for evoked currents only) A numeric value that represents the
#'  paired pulse ratio (PPR) of the evoked currents, generated using
#'  `dplyr::mutate(PPR = P2/P1)`.
#'  \item `interval` A character value indicating the interval that the data
#'  point belongs to. For example, `interval` will be "t0to5" for any data
#'  points from 0 to 5 minutes. Example values: "t0to5", "t5to10", etc.
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to TRUE when time is within the baseline period
#'  (e.g. Time <= 5) and FALSE at all other times.
#'  \item `baseline_mean` A numeric value representing the mean evoked current
#'  amplitude during the baseline period. There is a different baseline_mean for
#'  each letter.
#'  \item `P1_transformed` (for evoked currents only) A numeric value
#'  representing the first evoked current
#'  amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline.
#'  \item `P2_transformed` (for evoked currents only) A numeric value
#'  representing the second evoked current amplitude (pA) normalized relative to
#'  the mean amplitude during the recording's baseline.
#'  \item `amplitude_transformed` (for spontaneous currents only) A numeric
#'  value representing the spontaneous current amplitude (pA) normalized
#'  relative to the mean amplitude during the recording's baseline.
#' }
#'
#' @section Required basic columns:
#' It doesn't matter if the data are evoked or current type - these columns
#' should be included in your data.
#' \itemize{
#'  \item `letter` A character value that is a unique identifier for a single
#'  recording. Used to link data sets for evoked or spontaneous currents and
#'  cell-characteristics.
#'  \item `synapses` A character value (e.g. "Glutamate" or "GABA").
#'  \item `sex` A character value (e.g. "Male" or "Female").
#'  \item `treatment` A character value (e.g. "Control", "HNMPA").
#'  \item `time` A numeric value that represents time in minutes. This column is
#'  autogenerated in add_new_cells().
#'  \item `ID` A character value for the recording filename.
#'  \item `X` A numeric value representing the x-value of the cell's location in
#'  µm. Leave this blank if you don't have this data.
#'  \item `Y` A numeric value representing the y-value of the cell's location in
#'  µm. Leave this blank if you don't have this data.
#'  \item `age` A numeric value representing the animal's age. Can be any value
#'  as long as the time units are consistent throughout (e.g. don't mix up days
#'  and months when reporting animal ages).
#'  \item `animal` A numeric value representing the animal's ID or number.
#'  \item `category` A numeric value representing the experiment type. Used to
#'  assign top-level groups for further analyses, with `treatment` as subgroups.
#'  \item `cell` A character or numeric value representing the cell. For
#'  example, use `3.1.1` for animal #3, slice #1, cell #1.
#'}
#'
#' **Evoked current data**:
#'
#' If the data are evoked currents (`current_type == "eEPSC"`), the data must
#' contain the basic columns mentioned in **Required basic columns** plus these
#' columns:
#'
#' \itemize{
#'  \item `P1` A numeric value representing the
#'  amplitude of the first evoked current in pA.
#'  \item `P2` A numeric value representing the
#'  amplitude of the second evoked current in pA.
#' }
#'
#' **Spontaneous current data:**
#'
#' If the data are spontaneous currents (`current_type == "sEPSC"`), the data
#' must contain the basic columns mentioned in **Required basic columns** plus
#' these columns:
#'\itemize{
#'  \item `recording_num` A numeric value representing the recording number.
#'  This was incorporated before we switched to concatenating all recordings
#'  into one, but it needs to remain here to prevent breaking previous projects.
#'  It should be set to 1.
#'  \item `trace` A numeric value representing the trace (automatically
#'  generated in Clampfit) where the current occured.
#'  \item `time_of_peak` A numeric value representing the time of the peak in
#'  milliseconds relative to trace number. This is automatically calculated in
#'  Clampfit.
#'  \item `time` A numeric value representing the absolute time when the current
#'  happened, relative to the start of the recording. This is autogenerated. See
#'  add_new_cells() for a description of how the true time value (`time`) is
#'  calculated from the `recording_num` and `trace.`
#'  \item `amplitude` A numeric value representing the amplitude of the evoked
#'  current in pA.
#' }
#'
#' @examples
#' make_normalized_EPSC_data(
#'   filename = import_ext_data("sample_eEPSC_data.csv"),
#'   current_type = "eEPSC",
#'   min_time_value = 0,
#'   max_time_value = 25,
#'   interval_length = 5,
#'   baseline_length = 5,
#'   negative_transform_currents = "yes"
#' )
#'
#' @seealso add_new_cells() to add new recording data to your existing raw
#'   csv. It will merge raw data (a .csv with 4 columns: `letter`, `ID`, `P1`,
#'   and `P2`) and a `cell-characteristics.csv` file (with columns for factors
#'   like `animal`, `age`, `sex`, `synapses`).
#'
#' @export

make_normalized_EPSC_data <- function(filename = "Data/Sample-eEPSC-data.csv",
                                      current_type = "eEPSC",
                                      min_time_value = 0,
                                      max_time_value = 25,
                                      baseline_length = 5,
                                      interval_length = 5,
                                      negative_transform_currents = "yes",
                                      save_output_as_RDS = "no") {
  list_of_argument_names <- c(filename, current_type)

  if (is.null(current_type) ||
      length(current_type) != 1L ||
      !current_type %in% c("eEPSC", "sEPSC")) {
    stop("'current_type' argument must be one of: 'eEPSC' or 'sEPSC'")
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    stop("'save_output_as_RDS' argument must be one of: 'yes' or 'no'")
  }

  if (!negative_transform_currents %in% c("yes", "no")) {
    stop("'negative_transform_currents' argument must be one of: 'yes' or 'no'")
  }


  if (current_type == "eEPSC") {
    if (any(grepl("sEPSC", list_of_argument_names))) {
      stop(
        "current_type = \"",
        current_type,
        "\" but some arguments have the text ",
        "\"sEPSC\".",
        "\n Are you sure that you selected the correct current type?"
      )
    }
  }

  if (current_type == "sEPSC") {
    if (any(grepl("eEPSC", list_of_argument_names))) {
      stop(
        "current_type = \"",
        current_type,
        "\" but some arguments have the text ",
        "\"eEPSC\".",
        "\n Are you sure that you selected the correct current type?"
      )
    }
  }

  if (max_time_value %% baseline_length != 0) {
    stop(
      "max_time_value is ",
      max_time_value,
      ", which is not divisible by interval_length, ",
      interval_length
    )
  }

  raw_df <- utils::read.csv(here::here(filename), header = TRUE) %>%
    dplyr::rename_with(tolower)

  if (current_type == "eEPSC") {
    raw_df <- raw_df %>%
      dplyr::rename(
        ID = .data$id,
        P1 = .data$p1,
        P2 = .data$p2,
        X = .data$x,
        Y = .data$y
      )
  }

  if (current_type == "sEPSC") {
    raw_df <- raw_df %>%
      dplyr::rename(ID = .data$id,
                    X = .data$x,
                    Y = .data$y)
  }

  raw_df <- raw_df %>%
    dplyr::mutate(dplyr::across(
      c(
        .data$ID,
        .data$letter,
        .data$category,
        .data$treatment,
        .data$sex,
        .data$synapses
      ),
      as.factor
    )) %>%
    dplyr::filter(.data$time <= max_time_value)


  if (current_type == "eEPSC") {
    if (negative_transform_currents == "yes") {
      raw_df <- raw_df %>%
        dplyr::mutate(
          P1 = .data$P1 * -1,
          # Need positive current amplitude values to make plots more intuitive
          P2 = .data$P2 * -1,
          PPR = .data$P2 / .data$P1
        )
    } else {
      raw_df <- raw_df %>%
        dplyr::mutate(PPR = .data$P2 / .data$P1)
    }
  }

  # Divide data into intervals (e.g. 5-min intervals)


  time_sequence <- seq(from = min_time_value, to = max_time_value, by = interval_length)
  time_labels <- utils::head(paste0("t", time_sequence, "to", time_sequence + interval_length),
                             -1)

  raw_df <- raw_df %>%
    dplyr::mutate(
      interval = cut(
        .data$time,
        breaks = time_sequence,
        include.lowest = TRUE,
        labels = time_labels
      )
    ) %>%
    dplyr::group_by(.data$letter)

  # Within each cell, normalize all of the eEPSC amplitudes
  # relative to the mean baseline amplitude

  if (current_type == "eEPSC") {
    raw_df <- raw_df %>%
      dplyr::mutate(
        baseline_range = (.data$time <= baseline_length),
        baseline_mean = sum(.data$P1 * .data$baseline_range) / sum(.data$baseline_range),
        P1_transformed = (.data$P1 / .data$baseline_mean) * 100,
        P2_transformed = (.data$P2 / .data$baseline_mean) * 100
      )
  }

  if (current_type == "sEPSC") {
    raw_df <- raw_df %>%
      dplyr::mutate(
        baseline_range = (.data$time <= baseline_length),
        baseline_mean = sum(.data$amplitude * .data$baseline_range) / sum(.data$baseline_range),
        amplitude_transformed = (.data$amplitude / .data$baseline_mean) * 100
      )
  }

  return(raw_df)

  if (save_output_as_RDS == "yes") {
    saveRDS(raw_df, file = here::here(
      paste0("Data/Output-Data-from-R/raw_", current_type, "_df.RDS")
    ))
  }
}


#' Prune and summarize raw current data per minute
#'
#' `make_pruned_eEPSC_df()` creates a dataframe of evoked or spontaneous current
#' data summarized per minute (or some other user-defined interval). Current
#' amplitudes are collapsed down into the mean amplitude per minute. This is
#' equivalent to GraphPad Prism's "prune rows" function to reduce data to
#' summary values for every n rows.
#'
#' @param data A `data.frame` object generated using
#'   [make_normalized_EPSC_data()]. It must contain the columns outlined in the
#'   Required columns section below, which will already be generated for you
#'   from the output of [make_normalized_EPSC_data()].
#' @inheritParams make_normalized_EPSC_data
#' @param interval_length Length of each interval (in minutes). Used to divide
#'   the dataset into broad ranges for statistical analysis. Defaults to 1 for
#'   one summary point per minute.
#'
#' @returns A list containing 3 dataframes that can be viewed and used for
#'   further analyses in R. These dataframes are:
#'
#'   \itemize{
#'    \item `individual_cells`
#'    \item `for_table`
#'    \item `all_cells`
#'   }
#'
#'   I highly recommend assigning the list to an object
#'   named something like `pruned_eEPSC_df` to make it easy to reference the
#'   dataframes with logical names (e.g. `pruned_eEPSC_df$all_cells`). The
#'   dataframes are:
#'
#'\itemize{
#'  \item `individual_cells` A dataframe containing current data for each
#'  individual cell, but the data are reduced to a summary  point per per minute
#'  (or another value if a different `interval_length` is set). This dataframe
#'  contains columns already in the raw data, like `category`, `letter` and
#'  `sex` plus  new columns.
#'
#'  New columns for evoked current data (`current_type == "eEPSC"`) include:
#'  \itemize{
#'    \item `interval_pruned` A character value describing the interval that was
#'    used for the pruning function. If the data are pruned per minute, this
#'    will be "t0to1", "t1to2", "t2to3", etc.
#'    \item `mean_P1` The mean amplitude (in pA) of the first evoked current
#'    (P1) during a specific interval. This is an average of all data points
#'    within each interval. For example, the `mean_P1` for the interval "t0to1"
#'    contains the average current amplitude of all data points within the first
#'    minute of the recording.
#'    \item `sd_P1` The standard deviation of P1.
#'    \item `n` The number of data points used.
#'    \item `se` The standard error of P1.
#'    \item `cv` The coefficient of variation of P1.
#'    \item `cv_inverse_square` The inverse coefficient of variation, which is
#'    then squared. This is to enable variance analysis, as in
#'    [Huijstee & Kessels (2020)](https://doi.org/10.1016/j.jneumeth.2019.108526).
#'    \item `baseline_mean` The mean amplitude of the first evoked current
#'    during the baseline period.
#'    \item `category, letter, sex, treatment, etc.` Columns which are
#'    from the raw data. For a definition of these columns, please see the
#'    documentation for [make_normalized_EPSC_data()].
#'    \item `time` The upper time value of the interval (e.g. 2 minutes for
#'    "t1to2") which is used on the x-axis of plots such as in
#'    [make_raw_plots()].
#'  }
#'
#'  New columns for spontaneous current data (`current_type == "sEPSC"`)
#'  include:
#'  \itemize{
#'    \item `mean_amplitude` The mean amplitude of the normalized spontaneous
#'    current amplitude for a specific interval (obtained from
#'    [make_normalized_EPSC_data()]).
#'    \item `mean_raw_amplitude` The mean amplitude of the raw spontaneous
#'    current amplitude for a specific interval.
#'    \item `sd_amplitude` The standard deviation of the normalized spontaneous
#'    current amplitudes.
#'    \item `n` The number of currents
#'    \item `frequency` The frequency (in Hz) of currents during the interval.
#'    \item `se` The standard error of the normalized spontaneous current
#'    amplitudes.
#'    \item `letter, category, interval, synapses` Columns inherited from the
#'    raw data.
#'    \item `time` The upper time value of the interval (e.g. 2 minutes for
#'    "t1to2") which is used on the x-axis of plots such as in
#'    [make_summary_plot()].
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to TRUE when time is within the baseline period
#'  (e.g. Time <= 5) and FALSE at all other times.
#'    \item `baseline_mean_frequency` The mean spontaneous frequency during the
#'    baseline period.
#'    \item `frequency_transformed` The spontaneous current frequency (in Hz),
#'    normalized relative to the baseline current frequency.
#'  }
#'
#'  \item `for_table` A dataframe containing two columns: letter and
#'  `P1_transformed` (for `eEPSC`) or `spont_amplitude_transformed` (for
#'  `sEPSC`). The current data is collapsed into a single row for each letter,
#'  with the current data for each letter stored as a list. This is required to
#'  create sparklines of current amplitude over time within the cell summary
#'  table. See make_cell_summary_df() and make_interactive_summary_table().
#'
#'  \item `all_cells` A dataframe consisting of all data within a single
#'  treatment grouped and summarized per minute (or some other variable if you
#'  change `interval_length` to be something other than `1`). Columns like
#'  `category` and `sex` are retained from the raw data. New columns for evoked
#'  current data (`current_type == "eEPSC"`) are:
#'  \itemize{
#'    \item `interval_pruned` A character value describing the interval that was
#'    used for the pruning function. If the data are pruned per minute, this
#'    will be "t0to1", "t1to2", "t2to3", etc.
#'    \item `mean_P1_all_cells` The mean amplitude (in pA) of the first evoked
#'    current (P1) during a specific interval across all cells.
#'    \item `sd_P1_all_cells` The standard deviation of P1.
#'    \item `n` The number of data points used.
#'    \item `se_P1_all_cells` The standard error of P1.
#'    \item `cv_P1_all_cells` The coefficient of variation of P1.
#'  }
#'}
#'
#' @inheritSection make_normalized_EPSC_data Required basic columns
#'
#' @section Required evoked currents columns:
#'
#' These columns will all be generated automatically in
#' [make_normalized_EPSC_data()], but for more details, you can look at
#' [sample_raw_eEPSC_df] to see an example of what the incoming raw dataset in
#' the `data` argument should look like. If the data are evoked currents
#' (`current_type == "eEPSC"`), the data must contain the basic columns
#' mentioned in **Required basic columns** plus these columns:
#'
#' \itemize{
#'  \item `PPR` A numeric value that represents the paired pulse ratio (PPR) of
#'  the evoked currents, generated in
#'  [make_normalized_EPSC_data()]
#'  \item `interval` A character value indicating the interval that the data
#'  belong to (e.g. "t0to5" for the first 5 minutes, "t5to10"). Generated
#'  automatically in [make_normalized_EPSC_data()].
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to TRUE when time is within the baseline period
#'  (e.g. `time <= 5`) and FALSE at all other times. Generated automatically in
#'  [make_normalized_EPSC_data()].
#'  \item `baseline_mean` A numeric value representing the mean evoked current
#'  amplitude during the baseline period. There is a different baseline_mean for
#'  each letter. Generated automatically in [make_normalized_EPSC_data()].
#'  \item `P1_transformed` A numeric value representing the first evoked current
#'  amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline. Generated automatically in
#'  [make_normalized_EPSC_data()].
#'  \item `P2_transformed` A numeric value representing the second evoked
#'  current amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline. Generated automatically in
#'  [make_normalized_EPSC_data()].
#'}
#' @section Required spontaneous currents columns:
#' If the data are spontaneous currents (current_type == "sEPSC"), the data must
#' contain the basic columns mentioned in **Required basic columns** plus these
#' columns:
#'
#'\itemize{
#'  \item `interval` A character value indicating the interval that the data
#'  belong to (e.g. "t0to5" for the first 5 minutes, "t5to10"). Generated
#'  automatically in [make_normalized_EPSC_data()].
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to TRUE when time is within the baseline period
#'  (e.g. Time <= 5) and FALSE at all other times. Generated
#'  automatically in [make_normalized_EPSC_data()].
#'  \item `baseline_mean` A numeric value representing the mean evoked current
#'  amplitude during the baseline period. There is a different baseline_mean for
#'  each letter. Generated automatically in [make_normalized_EPSC_data()].
#'  \item `amplitude_transformed` A numeric value representing the spontaneous
#'  current amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline. Generated automatically in
#'  [make_normalized_EPSC_data()].
#'}
#'
#' @export
#'
#' @seealso [make_variance_data()] to see an example of how you can use pruned
#'   data to perform variance analysis to determine the mechanism of changing
#'   synaptic plasticity.
#'
#' @seealso [make_normalized_EPSC_data()] for a description of how baseline
#'   normalization works.
#'
#' @examples
#' make_pruned_EPSC_data(data = sample_raw_eEPSC_df,
#'   current_type = "eEPSC",
#'   min_time_value = 0,
#'   max_time_value = 25,
#'   baseline_length = 5,
#'   interval_length = 1)

make_pruned_EPSC_data <- function(data = patchclampplotteR::sample_raw_eEPSC_df,
                                  current_type = "eEPSC",
                                  min_time_value = 0,
                                  max_time_value = 25,
                                  baseline_length = 5,
                                  interval_length = 1,
                                  save_output_as_RDS = "no") {
  time_sequence <- seq(from = min_time_value, to = max_time_value, by = interval_length)
  time_labels <- utils::head(paste0("t", time_sequence, "to", time_sequence + interval_length),-1)

  if (is.null(current_type) ||
      length(current_type) != 1L ||
      !current_type %in% c("eEPSC", "sEPSC")) {
    stop("'current_type' argument must be one of: 'eEPSC' or 'sEPSC'")
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    stop("'save_output_as_RDS' argument must be one of: 'yes' or 'no'")
  }

  # Prune within individual cells
  pruned_df_individual_cells <- data %>%
    dplyr::mutate(
      interval_pruned = cut(
        .data$time,
        breaks = time_sequence,
        include.lowest = TRUE,
        labels = time_labels
      )
    ) %>%
    dplyr::group_by(.data$category,
                    .data$letter,
                    .data$sex,
                    .data$treatment,
                    .data$interval_pruned)

  if (current_type == "eEPSC") {
    pruned_df_individual_cells <- pruned_df_individual_cells %>%
      dplyr::reframe(
        mean_P1 = mean(.data$P1, na.rm = TRUE),
        # Mean amplitude per minute across all cells
        sd_P1 = stats::sd(.data$P1, na.rm = TRUE),
        n = dplyr::n(),
        se = .data$sd_P1 / sqrt(.data$n),
        cv = .data$sd_P1 / .data$mean_P1,
        cv_inverse_square = 1 / (.data$cv ^ 2),
        letter = unique(.data$letter),
        category = unique(.data$category),
        time = dplyr::last(.data$time),
        baseline_mean = unique(.data$baseline_mean),
        synapses = unique(.data$synapses)
      )

    pruned_df_for_table <- pruned_df_individual_cells %>%
      dplyr::group_by(.data$letter) %>%
      dplyr::summarize(P1_transformed = list(.data$mean_P1))
  }

  if (current_type == "sEPSC") {
    pruned_df_individual_cells <- pruned_df_individual_cells %>%
      dplyr::reframe(
        mean_amplitude = mean(.data$amplitude_transformed, na.rm = TRUE),
        mean_raw_amplitude = mean(.data$amplitude, na.rm = TRUE),
        sd_amplitude = stats::sd(.data$amplitude_transformed, na.rm = TRUE),
        n = dplyr::n(),
        # Gets number of currents within each minute
        frequency = .data$n / 60,
        # Frequency in Hz
        se = .data$sd_amplitude / sqrt(.data$n),
        letter = unique(.data$letter),
        category = unique(.data$category),
        interval = unique(.data$interval),
        synapses = unique(.data$synapses),
        time = dplyr::last(.data$time) # Time at interval end; used for plots
      ) %>%
      dplyr::group_by(.data$letter) %>%
      # Obtain normalized frequency
      dplyr::mutate(
        baseline_range = (.data$time <= baseline_length),
        baseline_mean_frequency = sum(.data$frequency * .data$baseline_range) / sum(.data$baseline_range),
        frequency_transformed = (.data$frequency / .data$baseline_mean_frequency) * 100
      )

    pruned_df_for_table <- pruned_df_individual_cells %>%
      dplyr::group_by(.data$letter) %>%
      dplyr::summarize(spont_amplitude_transformed = list(.data$mean_amplitude))
  }

  if (save_output_as_RDS == "yes") {
    saveRDS(pruned_df_individual_cells, file = here::here(
      paste0(
        "Data/Output-Data-from-R/pruned_",
        current_type,
        "_df_individual_cells.RDS"
      )
    ))
  }

  # Prune all cells
  if (current_type == "eEPSC") {
    pruned_df_all_cells <- data %>%
      dplyr::mutate(
        interval_pruned = cut(
          .data$time,
          breaks = time_sequence,
          include.lowest = TRUE,
          labels = time_labels
        )
      ) %>%
      dplyr::group_by(
        .data$category,
        .data$letter,
        .data$sex,
        .data$treatment,
        .data$interval_pruned
      ) %>%
      dplyr::reframe(
        mean_P1 = mean(.data$P1_transformed, na.rm = TRUE),
        sd_P1 = stats::sd(.data$P1_transformed, na.rm = TRUE),
        n = dplyr::n(),
        se = .data$sd_P1 / sqrt(.data$n),
        cv = .data$sd_P1 / .data$mean_P1 * 100,
        letter = unique(.data$letter),
        category = unique(.data$category),
        time = dplyr::last(.data$time)
      ) %>%
      dplyr::group_by(.data$category,
                      .data$interval_pruned,
                      .data$sex,
                      .data$treatment) %>%
      dplyr::reframe(
        mean_P1_all_cells = mean(.data$mean_P1, na.rm = TRUE),
        sd_P1_all_cells = stats::sd(.data$mean_P1, na.rm = TRUE),
        n = dplyr::n(),
        se_P1_all_cells = .data$sd_P1_all_cells / sqrt(.data$n),
        cv_P1_all_cells = .data$sd_P1_all_cells / .data$mean_P1_all_cells * 100,
        time = dplyr::last(.data$time),
        category = unique(.data$category),

      )
  }

  if (current_type == "sEPSC") {
    pruned_df_all_cells <- pruned_df_individual_cells %>%
      dplyr::ungroup() %>%
      dplyr::group_by(.data$category,
                      .data$interval_pruned,
                      .data$sex,
                      .data$treatment) %>%
      dplyr::reframe(
        mean_all_amplitude = mean(.data$mean_amplitude, na.rm = TRUE),
        mean_all_raw_amplitude = mean(.data$mean_raw_amplitude, na.rm = TRUE),
        sd_all_amplitude = stats::sd(.data$mean_amplitude, na.rm = TRUE),
        n = dplyr::n(),
        se_amplitude = .data$sd_all_amplitude / sqrt(.data$n),
        sd_all_raw_amplitude = stats::sd(.data$mean_raw_amplitude, na.rm = TRUE),
        se_raw_amplitude = .data$sd_all_raw_amplitude / sqrt(.data$n),
        mean_all_frequency = mean(.data$frequency_transformed, na.rm = TRUE),
        sd_all_frequency = stats::sd(.data$frequency_transformed, na.rm = TRUE),
        se_frequency = .data$sd_all_frequency / sqrt(.data$n),
        mean_all_raw_frequency = mean(.data$frequency, na.rm = TRUE),
        sd_all_raw_frequency = stats::sd(.data$frequency, na.rm = TRUE),
        se_raw_frequency = .data$sd_all_raw_frequency / sqrt(.data$n),
        time = dplyr::last(.data$time),
        interval = unique(.data$interval),
        category = unique(.data$category)
      )
  }

  if (save_output_as_RDS == "yes") {
    saveRDS(pruned_df_all_cells, file = here::here(
      paste0(
        "Data/Output-Data-from-R/pruned_",
        current_type,
        "_df_all_cells.RDS"
      )
    ))
  }

  return(
    list(
      individual_cells = pruned_df_individual_cells,
      for_table = pruned_df_for_table,
      all_cells = pruned_df_all_cells
    )
  )
}


#' Summarize current data per 5-min for statistical tests
#'
#' `make_summary_EPSC_data()` allows you to divide data from a long recording
#' (e.g. 30 minutes) into evenly-spaced intervals (e.g. 5 minutes). It will
#' generate summary data like the mean current amplitude for each interval. This
#' can be useful for inserting into statistical models to compare effect sizes
#' across broad stretches of time. The interval length would have been
#' previously specified in [make_normalized_EPSC_data()] using the
#' `interval_length` argument.
#'
#' @inheritParams make_pruned_EPSC_data
#'
#' @inheritSection make_normalized_EPSC_data Required basic columns
#' @inheritSection make_pruned_EPSC_data Required evoked currents columns
#' @inheritSection make_pruned_EPSC_data Required spontaneous currents columns
#' @returns A dataframe with summary data such as the mean current amplitude,
#'   coefficient of variation, standard deviation, standard error, variance,
#'   variance-to-mean ratio, and inverse coefficient of variation squared for
#'   each interval.

#'  \itemize{
#'  \item `letter` A character value that is a unique identifier for a single
#'  recording. Used to link data sets for evoked or spontaneous currents and
#'  cell-characteristics.
#'  \item `synapses` A character value (e.g. "Glutamate" or "GABA").
#'  \item `sex` A character value (e.g. "Male" or "Female").
#'  \item `treatment` A character value (e.g. "Control", "HNMPA").
#'  \item `time` A numeric value that represents time in minutes. This column is
#'  autogenerated in add_new_cells()].
#'  \item `ID` A character value for the recording filename.
#'  \item `P1` A numeric value representing the amplitude of the first evoked
#'  current in pA.
#'  \item `P2` A numeric value representing the amplitude of the second evoked
#'  current in pA.
#'  \item `X` A numeric value representing the x-value of the cell's location in
#'  µm. Leave this blank if you don't have this data.
#'  \item `Y` A numeric value representing the y-value of the cell's location in
#'  µm. Leave this blank if you don't have this data.
#'  \item `age` A numeric value representing the animal's age. Can be any value
#'  as long as the time units are consistent throughout (e.g. don't mix up days
#'  and months when reporting animal ages).
#'  \item `animal` A numeric value representing the animal's ID or number.
#'  \item `category` A numeric value representing the experiment type. Used to
#'  assign top-level groups for further analyses, with `treatment` as subgroups.
#'  \item `cell` A character or numeric value representing the cell. For
#'  example, use `3.1.1` for animal #3, slice #1, cell #1.
#'  \item `PPR` (for evoked currents only) A numeric value that represents the
#'  paired pulse ratio (PPR) of the evoked currents, generated using
#'  `dplyr::mutate(PPR = P2/P1)`.
#'  \item `interval` A character value indicating the interval that the data
#'  point belongs to. For example, `interval` will be "t0to5" for any data
#'  points from 0 to 5 minutes. Example values: "t0to5", "t5to10", etc.
#'  \item `baseline_range` A logical value required for the baseline
#'  transformation. It is set to TRUE when time is within the baseline period
#'  (e.g. Time <= 5) and FALSE at all other times.
#'  \item `baseline_mean` A numeric value representing the mean evoked current
#'  amplitude during the baseline period. There is a different baseline_mean for
#'  each letter.
#'  \item `P1_transformed` A numeric value representing the first evoked current
#'  amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline.
#'  \item `P2_transformed` A numeric value representing the second evoked
#'  current amplitude (pA) normalized relative to the mean amplitude during the
#'  recording's baseline.
#'}
#'
#' @export
#' @examples
#'
#' make_summary_EPSC_data(
#'   data = sample_raw_eEPSC_df,
#'   current_type = "eEPSC")
#'
make_summary_EPSC_data <- function(data = patchclampplotteR::sample_raw_eEPSC_df,
                                   current_type = "eEPSC",
                                   save_output_as_RDS = "no") {
  if (is.null(current_type) ||
      length(current_type) != 1L ||
      !current_type %in% c("eEPSC", "sEPSC")) {
    stop("'current_type' argument must be one of: 'eEPSC' or 'sEPSC'")
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    stop("'save_output_as_RDS' argument must be one of: 'yes' or 'no'")
  }

  if (current_type == "eEPSC") {
    summary_df <- data %>%
      dplyr::group_by(.data$category,
                      .data$letter,
                      .data$sex,
                      .data$treatment,
                      .data$interval) %>%
      dplyr::summarize(
        mean_P1_transformed = mean(.data$P1_transformed, na.rm = TRUE),
        mean_P1_raw = mean(.data$P1, na.rm = TRUE),
        n = dplyr::n(),
        sd = stats::sd(.data$P1_transformed, na.rm = TRUE),
        cv = .data$sd / .data$mean_P1_transformed,
        se = stats::sd(.data$P1_transformed, na.rm = TRUE) / sqrt(.data$n),
        cv_inverse_square = 1 / (.data$cv ^ 2),
        variance = stats::var(.data$P1_transformed, na.rm = TRUE),
        VMR = .data$variance / .data$mean_P1_transformed,
        age = unique(.data$age),
        # unique() retains unmodified columns that still should be included
        animal = unique(.data$animal),
        X = unique(.data$X),
        Y = unique(.data$Y),
        time = dplyr::last(.data$time),
        synapses = unique(.data$synapses)
      ) %>%
      dplyr::ungroup()
  }


  if (current_type == "sEPSC") {
    summary_df <- data %>%
      dplyr::group_by(.data$category,
                      .data$letter,
                      .data$sex,
                      .data$treatment,
                      .data$interval) %>%
      dplyr::summarize(
        mean_transformed_amplitude = mean(.data$mean_amplitude, na.rm = TRUE),
        mean_raw_amplitude = mean(.data$mean_raw_amplitude, na.rm = TRUE),
        sd_all_amplitude = stats::sd(.data$mean_amplitude, na.rm = TRUE),
        n = dplyr::n(),
        se_amplitude = .data$sd_all_amplitude / sqrt(.data$n),
        mean_transformed_frequency = mean(.data$frequency_transformed, na.rm = TRUE),
        sd_transformed_frequency = stats::sd(.data$frequency_transformed, na.rm = TRUE),
        se_frequency = .data$sd_transformed_frequency / sqrt(.data$n),
        mean_raw_frequency = mean(.data$frequency, na.rm = TRUE),
        time = dplyr::last(.data$time),
        interval = unique(.data$interval),
        category = unique(.data$category),
        synapses = dplyr::last(.data$synapses)
      )
  }

  if (save_output_as_RDS == "yes") {
    saveRDS(summary_df, file = here::here(
      paste0(
        "Data/Output-Data-from-R/summary_",
        current_type,
        "_df.RDS"
      )
    ))
  }

  return(summary_df)
}


#' Perform t-tests for EPSC summary plots
#'
#' This function enables you to perform a series of paired t-tests comparing the
#' mean current amplitude within each interval relative to the mean current
#' amplitude during the baseline. This uses the `paired_t_test` function from
#' `rstatix`, with `paired = TRUE` and Holm's adjustment for multiple
#' comparisons (`p.adjust.method = "holm"`). The resulting output table can also
#' be used to apply significance stars to the plot in [make_summary_plot()].
#'
#' @inheritParams make_baseline_comparison_plot
#' @inheritParams make_normalized_EPSC_data
#' @param test_category A numeric value describing the experimental category. In
#'   the sample dataset for this package, 2 represents experiments where insulin
#'   was applied continuously after a 5-minute baseline period.
#' @param parameter A character value specifying the parameter to be plotted on
#'   the y-axis. For evoked currents (`current_type = "eEPSC"`), the available
#'   parameter is "amplitude", which contains amplitudes normalized relative to
#'   the baseline. For spontaneous currents (`current_type = "sEPSC"`), the
#'   available parameters are "amplitude" (normalized currents),
#'   "raw_amplitude", "frequency" (normalized frequency) or "raw_frequency".
#'
#' @returns A dataframe
#' @export
#'
#' @seealso [make_normalized_EPSC_data()] for an example of how the normalized
#'   current amplitudes were created.
#'
#' @examples
#' perform_t_tests_for_summary_plot(data = sample_summary_eEPSC_df,
#'  test_category = 2,
#'  include_all_treatments = "yes",
#'  treatment_colour_theme = sample_treatment_names_and_colours,
#'  parameter = "amplitude",
#'  baseline_interval = "t0to5",
#'  interval_length = 5,
#'  list_of_treatments = NULL,
#'  current_type = "eEPSC",
#'  save_output_as_RDS = "no")

perform_t_tests_for_summary_plot <- function(data,
                                             test_category,
                                             include_all_treatments = "yes",
                                             list_of_treatments = NULL,
                                             treatment_colour_theme,
                                             baseline_interval,
                                             interval_length,
                                             parameter,
                                             current_type,
                                             save_output_as_RDS = "no") {
  if (is.null(current_type) ||
      length(current_type) != 1L ||
      !current_type %in% c("eEPSC", "sEPSC")) {
    stop("'current_type' argument must be one of: 'eEPSC' or 'sEPSC'")
  }

  if (!save_output_as_RDS %in% c("yes", "no")) {
    stop("'save_output_as_RDS' argument must be one of: 'yes' or 'no'")
  }

  if (!include_all_treatments %in% c("yes", "no")) {
    stop("'include_all_treatments' argument must be one of: 'yes' or 'no'")
  }

  if (include_all_treatments == "yes") {
    treatment_info <- treatment_colour_theme
    t_test_data <- data %>%
      dplyr::semi_join(treatment_info, by = c("treatment")) %>%
      dplyr::filter(.data$treatment %in% treatment_info$treatment)

    if (!is.null(list_of_treatments)) {
      warning(
        "include_all_treatments = \"yes\", but you included a list of treatments to filter. All treatments will be used."
      )
    }

  } else {
    if (is.null(list_of_treatments)) {
      stop(
        "include_all_treatments = \"",
        include_all_treatments,
        "\", but list_of_treatments is NULL.",
        "\nDid you forget to add a list of treatments?"
      )
    }

    if (!is.character(list_of_treatments)) {
      stop(
        "include_all_treatments = \"",
        include_all_treatments,
        "\", but list_of_treatments is not a character object.",
        "\nDid you forget to add a list of treatments?"
      )
    }

    if (is.null(baseline_interval) ||
        !is.character(baseline_interval)) {
      stop("'baseline_interval' must be a character (e.g. \"t0to5\" or \"t0to3\")")
    }

    treatment_info <- treatment_colour_theme %>%
      dplyr::filter(.data$treatment %in% list_of_treatments)
    t_test_data <- data %>%
      dplyr::filter(.data$treatment %in% list_of_treatments) %>%
      droplevels()
  }

  if (current_type == "eEPSC") {
    allowed_parameters_list <- "\"amplitude\""

    if (!parameter %in% c("amplitude")) {
      stop(
        "parameter must be ",
        allowed_parameters_list,
        " for current_type \"",
        current_type,
        "\". \nCheck parameter, current_type or data."
      )
    }

    if (parameter == "amplitude") {
      t_test_results <- t_test_data %>%
        dplyr::filter(.data$category == test_category) %>%
        dplyr::group_by(.data$treatment) %>%
        rstatix::pairwise_t_test(
          mean_P1_transformed ~ interval,
          ref.group = baseline_interval,
          paired = TRUE,
          p.adjust.method = "holm"
        )
    }
  }

  if (current_type == "sEPSC") {
    allowed_parameters_list <- "\"amplitude\", \"raw_amplitude\", \"raw_frequency\", or \"frequency\""

    if (!parameter %in% c("amplitude",
                          "raw_amplitude",
                          "frequency",
                          "raw_frequency")) {
      stop(
        "parameter must be ",
        allowed_parameters_list,
        " for current_type \"",
        current_type,
        "\". \nCheck parameter, current_type or data."
      )
    }

    if (parameter == "amplitude") {
      t_test_results <- t_test_data %>%
        dplyr::filter(.data$category == test_category) %>%
        dplyr::group_by(.data$treatment) %>%
        rstatix::pairwise_t_test(
          mean_transformed_amplitude ~ interval,
          ref.group = baseline_interval,
          paired = TRUE,
          p.adjust.method = "holm"
        )
    }

    if (parameter == "raw_amplitude") {
      t_test_results <- t_test_data %>%
        dplyr::filter(.data$category == test_category) %>%
        dplyr::group_by(.data$treatment) %>%
        rstatix::pairwise_t_test(
          mean_raw_amplitude ~ interval,
          ref.group = baseline_interval,
          paired = TRUE,
          p.adjust.method = "holm"
        )
    }

    if (parameter == "frequency") {
      t_test_results <- t_test_data %>%
        dplyr::filter(.data$category == test_category) %>%
        dplyr::group_by(.data$treatment) %>%
        rstatix::pairwise_t_test(
          mean_transformed_frequency ~ interval,
          ref.group = baseline_interval,
          paired = TRUE,
          p.adjust.method = "holm"
        )
    }

    if (parameter == "raw_frequency") {
      t_test_results <- t_test_data %>%
        dplyr::filter(.data$category == test_category) %>%
        dplyr::group_by(.data$treatment) %>%
        rstatix::pairwise_t_test(
          mean_raw_frequency ~ interval,
          ref.group = baseline_interval,
          paired = TRUE,
          p.adjust.method = "holm"
        )
    }
  }

  t_test_table <- t_test_results %>%
    dplyr::mutate(
      statistic = round(.data$statistic, 2),
      p_string = lazyWeave::pvalString(.data$p.adj),
      significance_stars = dplyr::case_when(.data$p.adj.signif == "ns" ~ "", T ~ .data$p.adj.signif)
    )

  # Need sequence of integers from 1 to the maximum number of intervals
  # to generate asterisk_time as a function of the number of intervals
  integer_sequence <- seq(1, length(unique(t_test_table$group2)), by = 1)

  positions_df <- data.frame(
    group2 = unique(t_test_table$group2),
    asterisk_time = (interval_length / 2) + interval_length * integer_sequence
  )

  t_test_table <- merge(positions_df, t_test_table, by = "group2") %>%
    dplyr::select(
      .data$treatment,
      .data$.y.,
      .data$group1,
      .data$group2,
      .data$n1,
      .data$n1,
      .data$statistic,
      .data$df,
      .data$p_string,
      .data$significance_stars,
      .data$asterisk_time
    ) %>%
    dplyr::arrange(match(.data$treatment, treatment_info$treatment))

  if (save_output_as_RDS == "yes") {
    saveRDS(t_test_table, file = here::here(
      paste0("Data/Output-Data-from-R/t_test_", current_type, ".RDS")
    ))
  }

  return(t_test_table)
}



#' Make variance analysis dataframe
#'
#' `make_variance_data` creates a dataframe containing variance measures at two
#' time points. They are the baseline period and a user-specified interval after
#' a hormone or protocol has been applied. The variance measures are the inverse
#' coefficient of variation squared and the variance-to-mean ratio (VMR). A
#' "before vs. after" comparison of these two variance measures is useful to
#' determine which mechanism is involved in modifying synaptic plasticity. For
#' more information, please see [Huijstee & Kessels
#' (2020)](https://doi.org/10.1016/j.jneumeth.2019.108526).
#'
#' @inheritParams make_baseline_comparison_plot
#' @inheritParams make_normalized_EPSC_data
#' @param df_category A numeric value describing the experimental category. In
#'   the sample dataset for this package, 2 represents experiments where insulin
#'   was applied continuously after a 5-minute baseline period. Here,
#'   `plot_treatment` represents antagonists that were present on the brain
#'   slice, or the animals were fasted, etc.
#' @param post_hormone_interval A character value indicating the name of the
#'   interval used as "after" timepoint for comparison. Defaults to "t20to25",
#'   but can be changed. Make sure that this matches an interval present in
#'   `data`
#'
#' @returns A dataframe containing all of the columns within the summary data
#'   (see [sample_summary_eEPSC_df] for a detailed description of these columns)
#'   plus three additional columns:
#' \itemize{
#' \item `state` A character value describing if a data point belongs to the
#' baseline interval ("Baseline") or an interval after a hormone or protocol has
#' been applied ("Post-modification"). These intervals are selected from
#' `baseline_interval` and `post_hormone_interval`.
#'  \item `mean_cv_inverse_square` The mean inverse coefficient of variation squared within a specific state.
#'  \item `mean_VMR` The mean variance-to-mean ratio within a specific state.
#'}
#'
#' @export
#'
#' @examples
#'
#' make_variance_data(data = sample_summary_eEPSC_df,
#'  df_category = 2,
#'  include_all_treatments = "yes",
#'  list_of_treatments = NULL,
#'  baseline_interval = "t0to5",
#'  post_hormone_interval = "t20to25",
#'  treatment_colour_theme = sample_treatment_names_and_colours,
#'  save_output_as_RDS = "no"
#' )
#'

make_variance_data <- function(data,
                               df_category,
                               include_all_treatments = "yes",
                               list_of_treatments = NULL,
                               baseline_interval,
                               post_hormone_interval,
                               treatment_colour_theme,
                               save_output_as_RDS = "no") {
  if (!save_output_as_RDS %in% c("yes", "no")) {
    stop("'save_output_as_RDS' argument must be one of: 'yes' or 'no'")
  }

  if (!include_all_treatments %in% c("yes", "no")) {
    stop("'include_all_treatments' argument must be one of: 'yes' or 'no'")
  }

  if (include_all_treatments == "yes") {
    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% treatment_colour_theme$treatment) %>%
      droplevels()

    treatment_info <- treatment_colour_theme

    if (!is.null(list_of_treatments)) {
      warning(
        "include_all_treatments = \"yes\", but you included a list of treatments to filter. All treatments will be used."
      )
    }

  } else {
    if (is.null(list_of_treatments)) {
      stop(
        "include_all_treatments = \"",
        include_all_treatments,
        "\", but list_of_treatments is NULL.",
        "\nDid you forget to add a list of treatments?"
      )
    }

    if (!is.character(list_of_treatments)) {
      stop(
        "include_all_treatments = \"",
        include_all_treatments,
        "\", but list_of_treatments is not a character object.",
        "\nDid you forget to add a list of treatments?"
      )
    }

    if (is.null(baseline_interval) ||
        !is.character(baseline_interval)) {
      stop("'baseline_interval' must be a character (e.g. \"t0to5\", \"t0to3\")")
    }

    if (is.null(post_hormone_interval) ||
        !is.character(post_hormone_interval)) {
      stop("'post_hormone_interval' must be a character (e.g. \"t20to25\")")
    }

    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% list_of_treatments) %>%
      droplevels()

    treatment_info <- treatment_colour_theme %>%
      dplyr::filter(.data$treatment %in% list_of_treatments)
  }



  variance_data <- dataframe %>%
    dplyr::filter(.data$category == df_category) %>%
    dplyr::filter(.data$interval == baseline_interval |
                    .data$interval == post_hormone_interval) %>%
    dplyr::mutate(
      state = dplyr::case_when(
        interval == baseline_interval ~ "Baseline",
        interval == post_hormone_interval ~ "Post-modification",
        T ~ interval
      )
    ) %>%
    dplyr::group_by(.data$treatment, .data$state) %>%
    dplyr::mutate(
      mean_cv_inverse_square = mean(.data$cv_inverse_square),
      mean_VMR = mean(.data$VMR)
    ) %>%
    dplyr::arrange(match(.data$treatment, treatment_info$display_names))

  return(variance_data)

  if (save_output_as_RDS == "yes") {
    saveRDS(variance_data, file = here::here(paste0(
      "Data/Output-Data-from-R/variance_data.RDS"
    )))
  }
}


#' Make paired-pulse ratio (PPR) dataframe for before vs. after comparisons
#'
#' This function filters the raw current data into data that belong to one of
#' two time points. They are the baseline period and a user-specified interval
#' after a hormone or protocol has been applied. The "before/after" comparison
#' of the paired-pulse ratio (PPR) is useful to determine which mechanism is
#' involved in modifying synaptic plasticity. For example, the PPR may be
#' related to the probability of neurotransmitter release [Oleskevich et al.,
#' 2000](https://doi.org/10.1111/j.1469-7793.2000.00513.x)
#'
#' @inheritParams make_baseline_comparison_plot
#' @inheritParams make_normalized_EPSC_data

#' @param data A dataframe containing the raw evoked current data generated from
#'   [make_normalized_EPSC_data()].
#' @param PPR_min A numeric value representing the minimum PPR value permitted
#'   in the filtered dataset. Defaults to 0.
#' @param PPR_max A numeric value representing the maximum PPR value permitted
#'   in the filtered dataset. Defaults to 5.
#' @param post_hormone_interval A character value specifying the interval used
#'   for the data points after a hormone or protocol was applied.
#'
#' @returns A dataframe containing all of the columns from
#'   [make_normalized_EPSC_data()], but filtered to only include PPR values
#'   between `PPR_min` and `PPR_max` within the `baseline_interval` and
#'   `post_hormone_interval`.
#'
#' @export
#'
#' @examples
#'
#' make_PPR_data(data = sample_raw_eEPSC_df,
#' include_all_treatments = "yes",
#' list_of_treatments = NULL,
#' PPR_min = 0,
#' PPR_max = 5,
#' baseline_interval = "t0to5",
#' post_hormone_interval = "t20to25",
#' treatment_colour_theme = sample_treatment_names_and_colours)
#'

make_PPR_data <- function(data,
                          include_all_treatments = "yes",
                          list_of_treatments = NULL,
                          PPR_min = 0,
                          PPR_max = 5,
                          baseline_interval,
                          post_hormone_interval,
                          save_output_as_RDS = "no",
                          treatment_colour_theme) {
  if (!save_output_as_RDS %in% c("yes", "no")) {
    stop("'save_output_as_RDS' argument must be one of: 'yes' or 'no'")
  }

  if (!include_all_treatments %in% c("yes", "no")) {
    stop("'include_all_treatments' argument must be one of: 'yes' or 'no'")
  }


  if (include_all_treatments == "yes") {
    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% treatment_colour_theme$treatment) %>%
      droplevels()

    treatment_info <- treatment_colour_theme

    if (!is.null(list_of_treatments)) {
      warning(
        "include_all_treatments = \"yes\", but you included a list of treatments to filter. All treatments will be used."
      )
    }

  } else {
    if (is.null(list_of_treatments)) {
      stop(
        "include_all_treatments = \"",
        include_all_treatments,
        "\", but list_of_treatments is NULL.",
        "\nDid you forget to add a list of treatments?"
      )
    }

    if (!is.character(list_of_treatments)) {
      stop(
        "include_all_treatments = \"",
        include_all_treatments,
        "\", but list_of_treatments is not a character object.",
        "\nDid you forget to add a list of treatments?"
      )
    }

    dataframe <- data %>%
      dplyr::filter(.data$treatment %in% list_of_treatments) %>%
      droplevels()

    treatment_info <- treatment_colour_theme %>%
      dplyr::filter(.data$treatment %in% list_of_treatments)
  }

  PPR_df <- dataframe %>%
    dplyr::filter(.data$PPR < PPR_max & .data$PPR > PPR_min) %>%
    dplyr::filter(.data$interval == baseline_interval |
                    .data$interval == post_hormone_interval) %>%
    dplyr::mutate(
      state = dplyr::case_when(
        interval == baseline_interval ~ "Baseline",
        interval == post_hormone_interval ~ "Post-modification",
        T ~ interval
      )
    ) %>%
    dplyr::arrange(match(.data$treatment, treatment_info$display_names))

  return(PPR_df)

  if (save_output_as_RDS == "yes") {
    saveRDS(PPR_df, file = here::here(paste0(
      "Data/Output-Data-from-R/PPR_df.RDS"
    )))
  }
}



